<details>
<summary>🧲 T결합도와 응집도에 대해 설명해주세요.

 </summary>
<br/>
결합도와 응집도는 코드 설계의 품질을 결정하는 중요한 개념들입니다.
먼저, 결합도는 서로 다른 모듈 간에 상호 의존하고 있는 정도가 얼마나 높은지를 의미합니다. 만약 결합도가 낮으면 모듈의 독립성이 높아져 변경이 용이해지고 코드의 재사용성이 증가합니다. 반면, 결합도가 높으면 한 모듈이 변경될 때 다른 모듈도 영향을 받을 가능성이 커집니다. 이로 인해 한 부분을 수정하면 연쇄적인 변경이 발생할 가능성이 높은데, 이는 유지보수를 어렵게 만듭니다. 이상적인 설계를 위해서는 결합도를 낮추는 것이 중요합니다.
응집도는 모듈 내부 요소들이 얼마나 밀접하게 서로 관련되어 있는지를 의미합니다. 응집도가 높을수록 모듈 내부의 기능이 단일한 목적을 가지고 있습니다. 이러한 특성은 가독성과 유지보수성에 도움이 됩니다. 반대로 응집도가 낮으면 하나의 모듈이 여러 가지 역할을 수행하게 되어 코드가 복잡해지고, 예측 가능성이 낮아져 수정할 때 예상치 못한 부작용이 발생할 가능성이 높아집니다. 따라서 이상적인 코드 설계를 위해서는 응집도를 높이는 것이 중요합니다.
주로 결합도와 응집도는 서로 반비례하는 경향이 있습니다. 일반적으로 결합도가 낮을수록 응집도가 높아지고, 반대로 결합도가 높으면 응집도가 낮아지는 경우가 많습니다.
결합도 및 응집도와 관련된 예시를 설명해주실 수 있나요? 🤔
예를 들어, 하나의 모듈이 다른 모듈의 내부 구현에 직접 접근한다면 결합도가 높은 상태입니다. 인터페이스를 통해 의존 관계를 느슨하게 만들면 결합도를 낮출 수 있습니다.
한편, 하나의 파일에서 사용자 인증과 데이터베이스 처리를 함께 담당한다면 응집도가 낮다고 볼 수 있습니다. 이러한 경우 인증 관련 로직과 데이터베이스 처리를 분리하여 각각의 책임을 명확히 하면 응집도를 높일 수 있습니다.

</details>
<br/>

<details>
<summary>⚠️ TDD란 무엇인지 설명해주세요.</summary>
<br/>
TDD(Test-Driven Development)는 소프트웨어 개발 방법론 중 하나로, **테스트를 먼저 작성한 후 실제 코드를 작성하는 방법론**입니다.

TDD는 일반적으로 ‘Red-Green-Refactor’ 사이클을 따릅니다. 첫 번째 단계는 Red로, 실패하는 테스트를 작성하는 것입니다. 이 테스트는 아직 구현되지 않은 기능에 대한 테스트로, 코드가 이를 통과하지 못하는 상태에서 시작됩니다. 두 번째 단계는 Green으로, 테스트를 통과할 수 있도록 최소한의 코드를 작성합니다. 이 단계에서는 테스트를 통과시키는 것만 목표로 하여 코드를 간결하게 작성합니다. 마지막 단계는 Refactor로, 작성한 코드를 리팩토링하여 가독성이나 성능을 개선합니다. 이때 테스트는 여전히 통과해야 하므로, 리팩토링이 기능에 영향을 미치지 않도록 합니다.

## **TDD에는 어떤 장점이 있나요? 🤔**

TDD는 여러 장점이 있습니다.

첫째, **디버깅 시간을 단축**할 수 있습니다. 자동화된 테스트를 통해 오작동하는 영역을 쉽게 좁혀나갈 수 있습니다.

둘째, **리팩토링이 용이**해집니다. 작성된 테스트가 리팩토링 후에도 코드가 올바르게 동작하는지 확인해 주기 때문에, 코드를 수정하는 데 자신감을 가질 수 있습니다.

셋째, **좋은 설계가 유도**됩니다. 테스트를 통해 요구 사항을 명확하게 이해하고, 이를 바탕으로 더 나은 설계를 할 수 있습니다. 또 각 기능을 테스트하기 용이하게 만드는 과정에서 자연스럽게 좋은 설계가 유도됩니다.

처음에는 테스트를 작성하는 데 시간이 소요될 수 있지만, 장기적으로는 위와 같은 장점들로 인해 생산성이 오히려 높아지는 효과를 누릴 수 있습니다.

</details>
<br/>

<details>
<summary>✅ Virtual DOM에 대해서 설명해주세요.</summary>
<br/>
Virtual DOM은 React에서 사용되는 핵심 개념으로, **실제 DOM을 JS 객체 형태로 복제한 가벼운 사본**이라고 할 수 있습니다. 브라우저의 DOM은 구조적으로 복잡하고, 이를 직접 조작하는 작업은 성능 비용이 상당히 높습니다. Virtual DOM은 이를 개선하여 웹 애플리케이션의 성능을 최적화하기 위해 등장했습니다.

Virtual DOM의 핵심 아이디어는 **상태 변경이 발생할 때마다 전체 UI를 Virtual DOM에 반영하고, 이를 이전 상태와 비교하여 필요한 부분에 한해서 최소한의 DOM 업데이트를 수행**하는 것입니다. Virtual DOM을 업데이트하고 비교하는 일은, 실제 DOM을 조작하지 않고 메모리 상에서 업데이트와 비교가 이뤄지기 때문에 가볍고 빠르게 수행됩니다.

React에서 Virtual DOM을 활용되는 구체적인 과정은 다음과 같습니다.

1. **상태 변경**: 컴포넌트의 상태나 props가 변경되면 Virtual DOM이 다시 생성됩니다.
2. **재조정(Reconciliation)**: 비교 알고리즘을 이용해 새로운 Virtual DOM과 이전 Virtual DOM 간의 차이를 계산합니다.
3. **re-render**: 계산된 차이에 따라 실제 DOM에서 필요한 부분만 업데이트합니다.

Virtual DOM은 이처럼 DOM 업데이트의 비용을 줄이고, 브라우저 렌더링 성능을 개선합니다.

## **React는 비교(diffing) 알고리즘을 어떻게 효율화했나요? 🤔**

React는 O(n³)의 복잡도를 가질 수 있는 트리 비교 문제를, 휴리스틱을 통해 O(n)으로 최적화했습니다.

휴리스틱 알고리즘은 크게 두 가지 가정을 두고 있습니다

### **1. 서로 다른 타입의 두 요소는 서로 다른 트리를 만들어낸다.**

DOM 요소의 타입이 다르면(ex. `<div>` → `<span>`) 비교를 수행하지 않고, 해당 요소와 그 자식들을 모두 새로 생성합니다. 자식 요소들의 내용이 같더라도 이전의 트리를 모두 버리고 완전히 새로 만듭니다. 이는 비효율적으로 보일 수 있지만, 실제 애플리케이션에서 타입이 다른 경우는 보통 완전히 다른 컴포넌트로 교체되는 상황이 많기 때문에 이 가정이 대부분의 경우 효율적입니다.

만약 동일한 타입의 요소라면, 동일한 내역은 유지하고 변경된 속성만 갱신합니다.

```jsx
<div className="before" title="stuff" /><div className="after" title="stuff" />

```

예를 들어, 이 예시에서는 `className`만 수정합니다.

### **2. 개발자가 key prop을 통해, 여러 렌더링 사이에서 어떤 자식 엘리먼트가 변경되지 않아야 할지 표시해 줄 수 있다.**

같은 레벨의 자식들을 비교할 때 개발자가 입력한 `key` prop을 사용하여 요소를 식별합니다. 이를 통해 리스트 내역의 일부가 수정됐을 때 모든 아이템 요소들을 불필요하게 갱신하지 않고, 실제 변경된 요소만 감지하여 효율적으로 갱신합니다.

</details>
<br/>

<details>
<summary>▶️ CI/CD란 무엇인지 설명해주세요</summary>
<br/>
CI/CD는 애플리케이션 배포 과정을 자동화하여 더 짧은 주기로 고객에게 서비스를 제공하는 방식입니다. 먼저, CI는 **Continuous Integration**의 약어로 **지속적 통합**을 의미합니다. CD는 **Continuous Delivery(지속적 전달)** 또는 **Continuous Deployment(지속적 배포)** 를 의미합니다.

먼저, **CI**는 **개발자들이 코드 변경사항을 주기적으로 메인 브랜치에 병합하는 과정을 자동화**한 것입니다. 이 과정에서 코드 변경사항이 발생할 때마다 자동으로 빌드와 테스트를 수행하여 문제를 조기에 발견할 수 있습니다. 예를 들어, 여러 개발자가 함께 작업할 때 한 개발자의 변경사항이 다른 개발자의 작업과 충돌하거나 전체 애플리케이션에 문제를 일으킬 수 있는데, CI를 거치면 이러한 문제를 병합 이전에 미리 파악할 수 있습니다.

**CD**는 **CI 이후 단계를 자동화**하는 것으로, 애플리케이션의 변경사항을 production 환경으로 배포하는 과정을 자동화한 것입니다. **Continuous Delivery**의 경우, **배포 가능한 상태로 준비하는 과정까지**는 자동화하고 실제 배포는 사람의 승인을 거쳐 수동으로 진행합니다. 반면, **Continuous Deployment**는 **production 환경에 배포하는 과정까지** 모두 자동화합니다.

현업에서는 GitHub Actions, Jenkins, GitLab CI 등의 도구를 사용하여 CI/CD 파이프라인을 구축합니다. CI/CD 프로세스에 대한 하나의 예시를 들면 다음과 같습니다.

1. 개발자가 PR을 올리면 자동으로 테스트/빌드 실행
2. 테스트/빌드를 성공한 경우 메인 브랜치로의 머지 활성화
3. 메인 브랜치 머지 시 production 환경으로 자동 배포
</details>
<br/>

<details>
<summary>🤫 모노레포란 무엇인가요?</summary>
<br/>
모노레포는 **mono(단일)** 와 **repo(레포지토리)** 를 합친 용어로, **여러 프로젝트 또는 패키지를 하나의 코드 저장소에 통합하여 관리하는 방식**을 의미합니다.

모노레포를 구성하기 위해 대표적으로 두 가지 구성 방식이 사용됩니다.

먼저, **프로젝트 단위로 분리된 구조**를 사용합니다. 모든 프로젝트가 하나의 저장소 안에서 각각 독립적인 폴더로 구성되며, 각 폴더는 독립적인 패키지로 관리됩니다. 이때 프로젝트 간의 공통 의존성은 `yarn workspaces`나 `npm workspaces` 같은 기능을 사용해 중앙에서 관리합니다. 이를 통해 중복된 의존성을 최소화하고, 프로젝트 간 코드 공유를 쉽게 합니다.

다음으로, **공통 모듈을 별도의 폴더로 분리하는 방식**을 사용합니다. 예를 들어, 여러 프로젝트에서 자주 사용하는 유틸리티 함수, 스타일, 공통 컴포넌트를 `shared`라는 폴더에 모아두고 각 프로젝트에서 이를 가져다 사용하는 방식입니다. 이렇게 하면 공통 코드를 한 번만 업데이트해도 여러 프로젝트에 즉시 반영할 수 있어 효율적입니다.

## **모노레포의 장점은 무엇인가요? 🤔**

첫째, **여러 프로젝트의 코드 및 설정 등을 일관되게 관리할 수 있다는 점입니다.** 예를 들어, 대규모 조직에서 여러 팀이 각기 다른 서비스를 개발하더라도, 모노레포를 통해 동일한 코드베이스에서 협력할 수 있습니다. 이를 통해 공통 모듈이나 설정 등을 공유하여, 불필요한 중복 작업을 줄이고 협업 효율성을 높일 수 있습니다.

둘째, **모노레포는 중앙화된 의존성 관리를 가능하게 해줍니다.** 예를 들어, 프로젝트 내에서 공통으로 사용되는 유틸리티나 컴포넌트를 한 번 업데이트하면 모든 관련 프로젝트에 즉시 적용할 수 있습니다.

또한, **여러 프로젝트들이 동일한 버전 관리 시스템을 공유할 수 있습니다.** 이를 통해 한 프로젝트에서 변경된 사항이 다른 프로젝트에 미치는 영향을 보다 명확히 추적할 수 있습니다.

## **모노레포의 단점은 없나요? 🧐**

물론, 모노레포에도 단점이 있습니다.

첫째, **스케일링이 복잡하고 어려워집니다**. 여러 프로젝트들이 모여 있으니 코드베이스가 빠르게 커지는데, 이때 빌드 및 테스트 시간이 그와 비례하여 길어집니다. 또한, CI/CD 파이프라인 관리의 복잡도가 증가합니다. 이러한 단점을 극복하기 위해 `Nx`, `Turborepo`와 같은 모노레포 관리 툴을 이용할 수 있습니다.

또한, **권한 관리가 까다로울 수 있습니다**. 모든 프로젝트가 하나의 저장소에 통합되기 때문에 특정 팀이나 프로젝트만 접근 권한을 가지도록 설정하는 것이 어렵습니다.

이러한 단점을 고려했을 때, 작은 규모의 팀이나 단일 프로젝트 중심의 개발 환경에서는 오히려 복잡성을 증가시킬 가능성이 있어 모노레포 사용이 적합하지 않을 수 있습니다.

</details>
<br/>

<details>
<summary>😋 알고 계신 git 브랜치 전략들에 대해 소개해주세요.</summary>
<br/>
주로 경험해본 전략으로는 **Git Flow, GitHub Flow, 그리고 Trunk-Based Development**가 있습니다.

먼저, **Git Flow**를 소개해 드리겠습니다. Git Flow에서 기능 개발은 `feature` 브랜치에서 이루어지고, 완료된 후 `develop` 브랜치에 병합됩니다. 릴리스를 준비할 때는 `release` 브랜치를 따로 만들어 QA와 최종 검증을 거친 뒤, 프로덕션 코드를 관리하는 `main`에 병합하게 됩니다. 만약 긴급한 수정 사항이 발생하면 `hotfix` 브랜치를 만들어 신속히 배포하고, 수정 사항을 `develop`에도 반영합니다. Git Flow를 이용하면 대규모 프로젝트에서 굉장히 체계적이고 안정적인 관리가 가능하지만, 브랜치가 많아짐에 따라 복잡도가 올라간다는 단점이 존재합니다.

다음으로, **GitHub Flow**는 Git Flow보다 단순한 구조를 가지고 있습니다. 모든 변경 사항은 `main` 브랜치 기준으로 이루어지는데요, 새로운 기능을 개발할 때 `feature` 브랜치를 생성한 뒤 작업이 끝나면 코드 리뷰를 받고 바로 `main`에 병합합니다. 이 방식은 간소화된 프로세스를 가지고 있기 때문에 짧은 주기의 배포 환경에서 특히 유용합니다. 하지만 릴리스와 QA를 위한 별도의 브랜치가 없기 때문에, 안정성 관리가 중요한 프로젝트에는 다소 부담스러울 수 있습니다.

마지막으로, **Trunk-Based Development**는 `main(또는 trunk)` 브랜치 하나만 운용하는 방식입니다. 작업을 `main` 브랜치에 직접 커밋하거나, `feature` 브랜치를 만들고 며칠 내에 빠르게 병합합니다. 병합 주기가 짧아 코드 충돌 가능성이 적다는 장점이 있습니다. 한편, 철저한 자동화 환경이 뒷받침되어야 한다는 단점이 존재합니다.

## **Git Flow와 Github Flow 중 어떤 전략을 선호하시나요? 🤔**

선호하는 하나의 전략이 있다기보다는, 프로젝트 상황에 맞는 전략을 선택하는 게 중요하다고 생각합니다.

**Git Flow**는 릴리스 주기가 길고 QA가 중요한 프로젝트에서 사용하기 적합합니다. 예를 들어, 금융 서비스처럼 안정성과 품질이 중요한 프로젝트에서는 Git Flow가 더 적합할 것입니다. 반면, **GitHub Flow**는 자주 배포가 이루어지고 변경 사항을 빠르게 반영해야 하는 스타트업과 유사한 환경에서 유리할 것입니다.

</details>
<br/>

<details>
<summary>💬 JSON Schema에 대해 설명해주세요. </summary>
<br/>
JSON Schema는 JSON 데이터의 형식을 기술하고 검증하기 위한 명세서입니다. 특정 JSON이 어떤 구조를 가져야 하는지를 명시할 수 있도록 해줍니다.

예를 들어 회원 정보에 대한 명세를 다음과 같이 작성할 수 있습니다.

{
"type": "object",
"properties": {
"username": { "type": "string", "minLength": 3 },
"email": { "type": "string", "format": "email" },
"password": { "type": "string", "minLength": 6 }
},
"required": ["username", "email", "password"],
"additionalProperties": false
}
JSON Schema가 어떻게 활용될 수 있는지 구체적으로 설명해 드리겠습니다.

먼저, 백엔드 API와의 통신 과정에서 데이터 형식을 검증하는 데 활용될 수 있습니다. 예를 들어 백엔드에서 데이터를 내려줄 때, JSON Schema를 활용하여 그 데이터가 어떤 속성들을 가지고 있는지, 타입은 어떤지, 필수인지 아닌지 정의할 수 있습니다. 그러면 프론트엔드에서는 그 스키마를 기준으로 데이터의 유효성을 검증할 수 있어서, API 통신에서 발생할 수 있는 오류를 사전에 방지할 수 있습니다.

JSON Schema는 정적 타입 생성 도구와 통합되어 사용되며 개발 생산성을 높여주기도 합니다. 예를 들어 json-schema-to-typescript 같은 도구를 사용하면 JSON Schema로부터 TypeScript 타입을 자동 생성할 수 있습니다. 이는 API 명세에 따라 타입을 작성하거나 수정하는 시간을 아껴주며, 스키마와 타입 간의 불일치를 줄이는 데 도움이 됩니다.

또한, 설정 파일에 대한 명세서로 활용될 수 있습니다. 예를 들어 eslintrc, tsconfig, prettierrc 같은 설정 파일들은 대부분 JSON 기반 형식을 사용하는데, JSON Schema Store에서 이러한 설정 파일들의 JSON Schema를 찾아볼 수 있습니다. VSCode와 같은 에디터에서 이 스키마를 기반으로 자동 완성, 타입 힌트, 경고 메시지 등을 지원하기 때문에, 설정 실수를 줄이고 생산성을 높이는 데 큰 도움이 됩니다.

</details>
<br/>

<details>
<summary>🏧 관계형 데이터베이스와 비관계형 데이터베이스에 대해 설명해주세요.
</summary>
<br/>
관계형 데이터베이스는 데이터를 테이블 형식으로 저장하고 관리하는 데이터베이스입니다. 각 테이블은 고정된 스키마를 가지며, 행(Row)은 개별 레코드, 열(Column)은 속성을 나타냅니다. 각 테이블은 고유한 스키마를 가지고 있어, 데이터 타입과 구조가 엄격하게 정의되어 있습니다. 대표적인 예로는 MySQL, PostgreSQL, Oracle이 있습니다.

관계형 데이터베이스는 정형화된 데이터를 다룰 때 특히 유용합니다. 미리 정의된 타입과 구조가 있기 때문에 이에 부합하는지 검증하여 데이터의 일관성을 유지하기 용이합니다. 또한, 데이터 간의 관계를 명확히 표현할 수 있는 것이 큰 장점입니다. 예를 들어 사용자와 주문 데이터를 각각 테이블로 만들고, 사용자 ID를 외래키로 설정해 두 테이블을 연결할 수 있습니다. 이를 통해 하나의 사용자에 속한 주문 내역을 정확히 조회할 수 있으며, 이 외에도 복잡한 조건의 데이터 조회나 조인을 처리하기 용이합니다.

반면, 흔히 NoSQL이라고 부르기도 하는 비관계형 데이터베이스는 전통적인 테이블 기반 구조가 아닌, 보다 유연한 데이터 모델을 사용합니다. "Key - value", "Document", "Graph" 등의 유형이 존재합니다. 비관계형 데이터베이스는 스키마가 고정되어 있지 않아서, 저장되는 데이터 구조가 일관되지 않아도 됩니다. 필요에 따라 유동적으로 속성을 추가할 수도 있습니다. 대표적인 예로는 MongoDB, Cassandra, Redis가 있습니다.

비관계형 데이터베이스의 장점은 유연성과 확장성입니다. 스키마가 고정되어 있지 않기 때문에, 초기 개발 단계에서 데이터 구조가 자주 변경될 가능성이 있는 프로젝트에 특히 적합합니다. 또한, 수평적 확장이 쉬워서 대용량의 데이터를 빠르게 처리하거나, 사용자가 급격히 늘어나는 상황에서도 안정적인 성능을 유지할 수 있다는 장점이 있습니다. 문서 기반 NoSQL에서는 하나의 객체에 필요한 데이터를 모두 담을 수 있어서, 관계를 맺고 조인하는 대신 한 번의 조회로 필요한 정보를 가져올 수 있다는 장점도 있습니다.

둘의 단점에 대해서도 간단히 설명해주실 수 있나요? 🤔
관계형 데이터베이스의 단점은 유연성이 떨어진다는 점입니다. 스키마가 고정돼 있기 때문에, 새로운 필드를 추가하거나 데이터 구조를 바꾸려면 테이블 자체를 수정해야 하고, 이로 인해 마이그레이션 과정이 복잡하고 시간이 오래 걸릴 수 있습니다. 또한, 서버를 여러 대로 분산시키는 수평적 확장이 상대적으로 어렵다는 단점도 있습니다. 관계형 데이터는 여러 테이블 간의 조인이 많기 때문에 데이터를 분산시켜 저장하면 성능 저하가 생길 수 있습니다. 그래서 대규모 트래픽을 처리해야 하는 시스템에서는 확장성이 한계로 작용할 수 있습니다.

비관계형 데이터베이스는 반대로 데이터의 일관성 유지가 어렵다는 문제가 있습니다. 스키마가 자유롭다 보니, 같은 컬렉션 안에 구조가 다른 문서들이 들어갈 수 있고, 그로 인해 나중에 데이터를 가공하거나 검증할 때 오류가 발생하기 쉽습니다. 또한, 조인 기능이 제한적이기 때문에, 데이터 간의 관계를 표현하는 데 한계가 있습니다. 만약 여러 컬렉션에 나눠 저장된 데이터를 합쳐서 조회해야 한다면, 애플리케이션 단에서 로직을 더 많이 처리해야 할 수도 있습니다.

</details>
<br/>

<details>
<summary>🏴‍☠️ XSS 공격이란 무엇이며, 프론트엔드에서 이를 방어하기 위한 방법을 설명해주세요.
 </summary>
<br/>
XSS(Cross-Site Scripting)는 공격자가 신뢰할 수 있는 웹사이트에 악성 스크립트를 삽입하여 사용자 브라우저에서 실행되게 하는 공격입니다. 이를 통해 쿠키 탈취, 세션 하이재킹, 피싱 등이 가능합니다.

XSS 공격은 크게 세 가지 유형이 있습니다.

첫번째로 저장형(Stored) XSS입니다. 악성 스크립트가 서버에 저장되어 다른 사용자가 해당 페이지를 방문할 때 실행됩니다.

두번째는 반사형(Reflected) XSS입니다. URL 파라미터 등을 통해 전달된 악성 스크립트가 서버 응답에 포함되어 실행됩니다.

마지막으로 DOM 기반 XSS입니다. 클라이언트 측 스크립트가 DOM을 동적으로 조작할 때 발생합니다.

해결 방법
이러한 보안문제를 해결하기 위한 방법으로는 입력 검증과 출력 이스케이핑이 있습니다. 사용자 입력을 적절히 검증하고, HTML 출력 시 특수 문자를 이스케이프 처리합니다.

아래처럼 element.innerHTML 대신 element.textContent를 이용하거나, DOMPurify를 사용하여 사용자의 입력값에 대해서 특수 문자와 입력 검증을 해줄 수 있습니다.

```
// ❌ 잘못된 방법
element.innerHTML = userInput;

// ✅ 올바른 방법
element.textContent = userInput; // 자동 이스케이프

// ✅ HTML이 필요한 경우 DOMPurify 사용
import DOMPurify from 'dompurify';
```

element.innerHTML = DOMPurify.sanitize(userInput);
혹은, 메타 태그에 Content-Security-Policy(CSP)를 설정하여 브라우저에 실행을 허용할 컨텐츠 소스를 제한할 수 있습니다.

```
<!-- HTTP 헤더 또는 메타 태그로 설정 -->
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://trusted-cdn.com;">
```

마지막으로는 HttpOnly 쿠키입니다. 쿠키에 HttpOnly 플래그를 설정하여 자바스크립트를 통한 접근을 차단할 수 있습니다.

</details>
<br/>

<details>
<summary>🤚 TLS 핸드셰이크 과정에 대해 설명해주세요.
  </summary>
<br/>
TLS 핸드셰이크는 브라우저와 서버가 TLS 프로토콜을 통해 암호화된 통신을 시작하기 전, 안전하게 연결을 설정하는 절차입니다. 이 절차는 보통 다음과 같은 흐름으로 이뤄집니다.

먼저 브라우저는 Client Hello 메시지를 보냅니다. 여기에는 브라우저가 지원하는 TLS 버전, 사용할 수 있는 암호화 알고리즘 목록, 세션 ID, 그리고 Client Random이라는 난수가 포함되어 있습니다.

서버는 이에 대해 Server Hello로 응답하면서, 서버가 선택한 암호화 방식, 자신의 Server Random 값, 그리고 디지털 인증서를 함께 보냅니다. 이 인증서 안에는 서버의 공개키와 CA의 서명이 포함되어 있으며, 브라우저는 이걸 통해 서버의 신원을 검증합니다.

검증이 완료되면 브라우저는 서버의 공개키로 Pre-Master Secret이라는 임시 비밀 값을 암호화해서 전송합니다. 서버는 자신의 개인키로 이를 복호화해 Pre-Master Secret 값을 복원하고, 이제 클라이언트와 서버는 서로 갖고 있는 Client Random, Server Random, 그리고 Pre-Master Secret을 기반으로 동일한 대칭키를 생성합니다. 이 대칭키는 이후 주고 받는 데이터를 암호화하고 복호화하는 데 사용됩니다.

마지막으로 서로 Finished 메시지를 교환하면서 대칭키로 암호화된 통신이 잘 되는지 확인하고 나면, 정상적인 HTTPS 통신이 시작됩니다.

</details>
<br/>

<details>
<summary>📱 User-Agent에 대해서 설명해주세요. </summary>
<br/>
User-Agent는 HTTP 요청 헤더에 포함되는 문자열로, 웹 서버에 접속하는 클라이언트(브라우저, 운영체제, 디바이스 등)의 정보를 식별하는 데 사용됩니다.

이 문자열에는 브라우저 종류, 버전, 운영체제, 렌더링 엔진 등의 정보가 포함되어 있습니다. 프론트엔드 개발자로서 User-Agent는 특정 브라우저에 맞는 기능을 제공하거나, 디바이스에 따른 최적화를 구현할 때 참고할 수 있습니다.

하지만 현대적인 웹 개발에서는 User-Agent 문자열에 의존하기보다는 기능 감지(feature detection)와 반응형 디자인을 통해 크로스 브라우징 이슈를 해결하는 것이 권장됩니다.

JavaScript에서는 navigator.userAgent를 통해 User-Agent 정보에 접근할 수 있으며, 서버 측에서는 HTTP 요청 헤더에서 이 정보를 확인할 수 있습니다.

</details>
<br/>

<details>
<summary>🧑‍💻 웹표준이란? </summary>
<br/>
웹표준은 다양한 웹 기술들이 브라우저나 기기와 상관없이 일관되게 동작하도록 보장하기 위한 규약들의 집합입니다. HTML, CSS, JavaScript와 같은 핵심 기술뿐만 아니라 접근성, 통신, 보안 등 여러 영역까지 포괄하며, IETF, W3C 등의 국제 표준 기구에서 정의하고 관리합니다.

웹표준의 목적은 다양한 브라우저, 기기, 플랫폼에서 웹 페이지가 동일하게 작동하도록 보장하는 것입니다. 먼저, 개발자 입장에서는 웹표준을 따름으로써 특정 브라우저에 종속되지 않는 코드를 작성할 수 있습니다. 즉, 특정 환경에 맞추어 여러 버전을 만들 필요 없이 한 번의 개발로 여러 환경의 사용자에게 서비스를 제공할 수 있습니다. 또한 사용자 입장에서는 어떤 브라우저나 기기를 사용하더라도 콘텐츠가 일관되게 표현되므로 더 나은 접근성과 사용자 경험을 얻을 수 있게 됩니다.

예를 들어, HTML에서 시맨틱 태그를 사용하면 콘텐츠의 의미와 구조를 명확하게 표현할 수 있으며, CSS의 표준 속성은 스타일의 일관성을 보장합니다. JavaScript도 ECMAScript 표준에 따라 구현되므로, 서로 다른 브라우저 간에 전반적인 동작의 일관성을 유지할 수 있습니다.

## 웹표준을 지키지 않을 때 발생할 수 있는 문제는 무엇인가요? 🤔

웹표준을 따르지 않으면 몇몇 브라우저 환경에서 웹사이트가 의도한 대로 동작하지 않거나 레이아웃이 깨지는 등의 문제가 발생할 수 있습니다. 또한, 특정 기능이 브라우저에서 비활성화되거나 보안 취약점으로 이어질 가능성도 존재합니다. 특히, 모바일 환경에서는 기기 종류가 다양하므로 표준을 지키지 않으면 사용자 경험이 크게 저하될 수 있습니다.

</details>
<br/>
