<details>
<summary>👨‍🎨 reflow와 repaint의 차이점에 대해서 설명해주세요.</summary>
<br/>
reflow와 repaint는 웹 페이지가 렌더링 되는 과정에서 발생하는 중요한 작업들입니다.
먼저, reflow에 관해 설명하겠습니다. reflow는 브라우저가 페이지의 레이아웃을 다시 계산하는 과정을 말합니다. DOM의 구조가 변경되거나 CSS 스타일이 변경되면, 브라우저는 각 요소가 화면에 어떻게 배치될지 다시 계산해야 합니다. 이 과정은 모든 자식 요소와 관련된 부모 요소까지 영향을 주기 때문에 비용이 많이 드는 작업입니다. 예를 들어, CSS에서 요소의 width나 height 속성을 변경하면, 브라우저는 해당 요소뿐만 아니라 연관된 모든 요소의 배치를 다시 계산해야 합니다.
반면에, repaint는 요소의 모양이나 스타일이 변경될 때 발생합니다. 요소의 레이아웃은 그대로이고, 색상이나 배경 등의 스타일만 변경되는 경우를 말합니다. background-color 같은 속성을 예로 들 수 있습니다. 이 경우 브라우저는 요소의 모양만 다시 그리면 되기 때문에 reflow보다는 비용이 덜 들지만, 여전히 성능에 영향을 줄 수 있습니다.
reflow는 레이아웃을 다시 계산하는 과정이고, repaint는 그 계산 결과를 화면에 다시 그리는 과정이라고 할 수 있습니다. 이 둘을 잘 이해하고 관리한다면 성능 최적화에 큰 도움이 됩니다.
둘을 잘 관리하는 것이 성능 최적화에 도움이 된다고 하셨는데, 최적화 방법에는 무엇이 있을까요?
최적화하는 데에 여러 가지 방법이 있는데요. 크게 3가지 정도 말씀드려볼 수 있을 거 같습니다.
첫 번째로 reflow를 유발하는 CSS 속성 사용을 최소화하는 것입니다.
width, height, margin, padding, border 등의 속성은 요소의 레이아웃을 다시 계산하게 하므로 reflow를 일으킵니다. 가능한 한 미리 CSS에서 스타일을 설정해 초기 로드 시에만 계산이 이루어지도록 하고, 이후에는 변경하지 않는 것이 좋습니다.
두 번째로 CSS 애니메이션 최적화입니다. 애니메이션에 transform과 opacity 속성만을 사용하는 것이 성능에 유리합니다. 이 두 속성은 GPU 가속을 사용할 수 있어 reflow를 일으키지 않고 repaint만 발생시키므로 CPU 자원을 적게 사용합니다.
마지막으로 will-change 속성 사용입니다. CSS의 will-change 속성을 사용하여 브라우저에 특정 요소가 변경될 것이라고 미리 언질을 줄 수 있습니다. 예를 들어, will-change: transform으로 미리 GPU에서 요소를 준비하게 하여 reflow 및 repaint에 미치는 영향을 줄일 수 있습니다. 하지만 will-change 속성은 너무 자주 사용하면 메모리 낭비가 발생하므로 필요한 요소에만 적용해야 한다는 주의점 또한 존재합니다.

</details>
<br/>

<details>
<summary>📈 브라우저 렌더링 파이프라인에 대해서 설명해주세요.   </summary>
<br/>
브라우저가 웹 페이지를 화면에 표시하기 위해 거치는 과정을 브라우저 렌더링 파이프라인이라고 합니다. 이 과정은 크게 5단계로 나눌 수 있습니다.

### 첫번째로 **DOM 생성**입니다.

브라우저가 HTML 파일을 받으면, 이 파일을 바이트(byte) 단위로 읽기 시작합니다. 브라우저의 HTML 파서(Parser)는 이 바이트들을 문자(character)로 변환하고, 이 문자들을 다시 HTML 토큰으로 변환합니다. 이 HTML 토큰들은 각각의 태그와 그 안에 포함된 텍스트, 속성 등을 의미하게 됩니다.

HTML 토큰이 생성되면, 브라우저는 이를 기반으로 **DOM 트리**를 생성합니다. **DOM 트리**는 HTML 문서의 구조를 트리 형태로 표현한 것으로, 각 태그가 노드(node)가 되어 부모-자식 관계를 형성합니다. 예를 들어, `<body>` 태그 아래에 `<div>`가 있다면, DOM 트리에서도 `<body>` 노드 아래에 `<div>` 노드가 있게 됩니다.

### 두번째로 **CSSOM 생성**입니다.

브라우저는 CSS 파일을 파싱(parse)합니다. CSS 파일 역시 바이트로 전송되므로, 브라우저는 이를 문자로 변환한 뒤, CSS 규칙으로 나눕니다. 각 CSS 규칙은 `선택자(selector)`와 `선언(declaration)`으로 구성되는데, 선택자는 스타일을 적용할 HTML 요소를 정의하고, 선언은 적용할 스타일을 정의합니다.

브라우저는 이 CSS 규칙들을 기반으로 **CSSOM 트리**를 생성합니다. CSSOM 트리는 DOM과 유사하게 트리 구조를 가지며, 각 노드는 해당 노드에 적용될 스타일 정보를 포함합니다.

### 세번째로 **렌더 트리 생성**입니다.

이제 브라우저는 DOM과 CSSOM을 결합하여 **렌더 트리**를 생성합니다. 렌더 트리는 화면에 실제로 표시될 요소들로만 구성됩니다. 예를 들어 display: none 속성이 있는 요소는 렌더 트리에 포함되지 않습니다. 이는 렌더 트리가 실제로 화면에 그려질 요소들만을 포함하기 때문입니다.

렌더 트리의 각 노드는 DOM 트리의 요소와 연결되며, CSSOM 트리에서 해당 요소에 적용된 스타일 정보를 포함합니다. 즉, 렌더 트리는 HTML 문서의 구조와 각 요소의 스타일 정보를 모두 포함한 트리입니다.

### 네번째로 **레이아웃**입니다.

렌더 트리가 생성된 후, 브라우저는 이 트리를 사용해 각 요소의 정확한 위치와 크기를 계산합니다. 이 과정이 바로 레이아웃(Layout)입니다. 레이아웃 과정에서는 렌더 트리의 각 노드가 화면의 어디에 위치할지, 그리고 얼마나 큰지를 계산하게 됩니다.

이 계산은 화면의 뷰포트(viewport) 크기와 같은 정보에 의존합니다. 예를 들어, 화면 크기가 변경되면 브라우저는 레이아웃 과정을 다시 수행해야 합니다. 이 과정을 흔히 '리플로우(Reflow)'라고 부르는데, 리플로우는 성능에 영향을 줄 수 있으므로 이를 최소화하는 것이 중요합니다.

### 다섯번째로 **페인팅**입니다.

레이아웃이 완료되면, 브라우저는 각 요소를 실제로 화면에 그리는 작업을 시작합니다. 이 과정을 페인팅이라고 합니다. 페인팅 단계에서는 텍스트, 색상, 그림자, 이미지 등 모든 시각적 요소가 화면에 그려집니다.

페인팅은 화면에 표시될 그래픽 요소를 생성하는 과정이기 때문에, 이 과정도 성능에 큰 영향을 줄 수 있습니다. 특히, 복잡한 그래픽이나 애니메이션이 포함된 경우 페인트 작업이 많아져 성능이 저하될 수 있습니다.

### 마지막 단계는 **컴포지팅**입니다.

브라우저는 화면에 그려질 요소들을 각각의 레이어(layer)로 분리하고, 이 레이어들을 결합하여 최종 화면을 구성합니다. 이 과정에서는 GPU를 활용하여 각 레이어를 빠르게 합성합니다.

transform과 opacity와 같은 속성은 레이아웃이나 페인트 과정을 거치지 않고, 이 컴포지팅 단계에서만 처리됩니다. 이 덕분에 이러한 속성을 사용하는 애니메이션은 더 부드럽고 빠르게 실행될 수 있습니다. 컴포지팅 단계는 GPU 가속을 활용하여 성능을 최적화하고, 화면에 최종적으로 표시되는 결과를 빠르게 생성하는 데 중요한 역할을 합니다.

</details>
<br/>

<details>
<summary>💻 인터넷 창에 www.google.com를 입력하면 무슨 일이 일어나는지 설명해주세요.   </summary>
<br/>
첫번째로 **DNS 조회**가 일어납니다. 사용자가 "[www.google.com"을](http://www.google.xn--com"-jy1s/) 입력하면, 브라우저는 먼저 이 도메인 이름을 IP 주소로 변환해야 합니다. 이 과정을 DNS 조회(DNS Lookup)라고 합니다. 브라우저는 캐시된 DNS 기록을 먼저 확인하고, 없으면 로컬 DNS 서버에 요청하여 "[www.google.com"에](http://www.google.xn--com"-eg0s/) 해당하는 IP 주소를 얻습니다.

두번째로 **TCP 연결 수립**입니다. IP 주소가 확인되면, 브라우저는 서버와 TCP 연결을 수립합니다. TCP(Transmission Control Protocol)는 데이터를 신뢰성 있게 전달하기 위한 프로토콜입니다. 이 과정에서 브라우저는 서버와 3-way handshake를 수행합니다. 즉, 브라우저가 SYN 패킷을 보내고, 서버가 SYN-ACK 패킷을 보내며, 다시 브라우저가 ACK 패킷을 보내는 과정입니다.

세번째로 **HTTP 요청**입니다. TCP 연결이 수립되면, 브라우저는 HTTP 또는 HTTPS 요청을 보냅니다. 이 요청은 "GET / HTTP/1.1" 같은 형식으로, 웹 페이지를 요청하는 메시지입니다. HTTPS를 사용할 경우, 이 단계에서 SSL/TLS 핸드셰이크도 수행됩니다. 이 과정에서는 브라우저와 서버가 암호화된 연결을 설정하기 위해 보안 인증서를 교환하고, 암호화 키를 협상합니다.

네번째로 **서버의 응답**을 받습니다. 서버는 요청을 받고, 해당 리소스(HTML, CSS, JavaScript, 이미지 등)를 브라우저에게 응답으로 보냅니다. 이 응답은 HTTP 응답 코드(예: 200 OK)와 함께 전달됩니다.

마지막으로 받은 리소스들을 바탕으로 **브라우저 렌더링 파이프라인을 진행**합니다. DOM과 CSSOM을 생성하고, 렌더 트리를 구성한 뒤, 레이아웃과 페인트 단계를 통해 웹 페이지가 화면에 표시됩니다.

</details>
<br/>

<details>
<summary>🔥 웹 애플리케이션의 성능을 최적화할 수 있는 방법들에 대해서 아는대로 설명해주세요.
 </summary>
<br/>
웹 애플리케이션 성능 최적화에는 여러 가지 방법이 있습니다.

우선, **코드 스플리팅을 통해 자바스크립트 파일을 필요한 부분만 나누어 로드**할 수 있습니다. 이렇게 하면 모든 코드를 한꺼번에 불러오는 대신, 사용자가 즉시 필요한 부분만 먼저 로드하여 페이지 로딩 속도를 개선할 수 있습니다.

또한, **레이지 로딩 기법을 사용하여, 페이지에 있는 이미지나 비디오 같은 무거운 리소스를 사용자가 실제로 볼 때만 로드하는 방식**을 적용할 수 있습니다. 예를 들어, 사용자가 페이지를 스크롤할 때 하단의 이미지가 필요해지면 그때 비로소 이미지를 불러오는 것입니다. 이렇게 하면 불필요한 리소스 로딩을 줄여 성능을 높일 수 있습니다.

이미지에 대해서는 **파일의 물리적인 크기를 알맞게 줄이거나 WebP와 같은 가벼운 포맷으로 변환하는 방법**이 있습니다. 이를 통해 불필요한 용량을 줄이고 로딩 속도를 향상시킬 수 있습니다.

또한, **캐싱을 활용하면, 한 번 로딩된 리소스를 다시 다운로드하지 않고 브라우저가 캐시된 데이터를 재사용하여 성능을 크게 향상**시킬 수 있습니다. 적절한 캐시 정책을 설정하는 것이 매우 중요합니다.

자바스크립트 로딩 시에는 **비동기 로딩(async)** 이나 **지연 로딩(defer)** 을 적용하여 자바스크립트가 DOM을 차단하지 않도록 할 수 있습니다. 이를 통해 페이지가 로딩되는 동안에도 자바스크립트 파일을 병렬로 불러오거나, 적절한 타이밍에 로드하게 되어 사용자 경험이 더 쾌적해질 수 있습니다.

</details>
<br/>

<details>
<summary>❗️ 디바운스와 쓰로틀에 대해서 각각 설명해주세요.
 </summary>
<br/>
**디바운스(debounce)** 와 **쓰로틀(throttle)** 은 **이벤트 핸들러가 너무 자주 실행되지 않도록 조절하는 기법**입니다. 이 두 가지 방법은 비슷해 보이지만, 동작 방식에 차이가 있습니다.

먼저, **디바운스**에 대해서 설명 드리겠습니다. **디바운스**는 이벤트가 연속적으로 발생할 때, **마지막 이벤트가 발생한 후 일정 시간이 지나야 이벤트 핸들러가 실행**되는 방식입니다. 이를 통해 불필요하게 많은 이벤트 호출을 방지할 수 있습니다. 예를 들어, 검색창에 사용자가 키를 입력할 때마다 검색 요청을 보내면 부하가 지나치게 커지기 때문에, 사용자가 입력을 멈춘 후 일정 시간이 지나면 검색 요청을 보내는 방식으로 디바운스를 적용할 수 있습니다.

**쓰로틀**은 **일정 시간 간격 동안 발생한 이벤트 중 첫 번째 또는 마지막 이벤트만 처리**하는 방식입니다. 즉, 이벤트가 계속해서 발생하더라도 설정된 시간 동안은 한 번만 이벤트 핸들러가 실행됩니다. 예를 들어, 사용자가 연속 클릭을 한다면 클릭할 때마다 이벤트가 발생하는데, 이를 매번 처리하면 부하가 불필요하게 커지니, 쓰로틀을 적용해 일정 간격 내 한 번만 처리하게 할 수 있습니다.

정리하자면, **디바운스**는 **마지막 이벤트 이후에 딜레이를 두고 처리**하며, **쓰로틀**은 **일정 시간 간격을 두고 이벤트를 처리**하는 방식입니다.

## **디바운스와 쓰로틀 중에서 무한 스크롤 구현 시 어떤 방식을 선택하시겠습니까? 그 이유는 무엇인가요?**

무한 스크롤 구현 시에는 **쓰로틀**을 사용하는 것이 더 적합합니다. 그 이유는 다음과 같습니다:

먼저, 스크롤은 연속적인 동작이며 사용자가 페이지 하단에 도달했을 때 즉각적인 반응을 기대합니다. **쓰로틀**은 스크롤이 **하단에 위치하게 된 순간 즉시 추가 데이터 요청을 수행**하므로, 사용자에게 더 자연스러운 스크롤 경험을 제공할 수 있습니다.

반면, **디바운스**를 사용할 경우, 사용자가 반복적으로 스크롤한다면 **스크롤이 멈춘 후에야 데이터를 불러오기 시작하므로 지연**이 발생할 수 있습니다. 반면 쓰로틀은 스크롤 중에도 주기적으로 체크하므로,

따라서 무한 스크롤에서는 쓰로틀을 사용하여 스크롤이 하단에 위치한 즉시 데이터를 선제적으로 로드하는 것이 좋습니다.

</details>
<br/>

<details>
<summary>🐭 웹 접근성의 개념과 개선 방법에 대해 설명해주세요.
 </summary>
<br/>
**웹 접근성**은 **장애인과 고령자 등 신체적 제약이 있는 사용자를 포함해, 모든 사용자가 웹 페이지를 동등하게 이용할 수 있도록 보장**하는 개념입니다. 마치 공공건물에 휠체어 경사로를 설치해 이동이 불편한 사람도 이용할 수 있게 하는 것처럼, 웹 페이지 역시 디지털 경사로를 마련해 누구나 접근할 수 있어야 합니다. 다만 접근성은 단순히 장애인만을 위한 것이 아닙니다. 네트워크 속도가 느리거나 밝은 햇빛 아래 화면을 보는 등 일상적인 제약 상황에서도, **모든 사용자가 제약 없이 웹을 사용할 수 있도록 하는 것**이 웹 접근성의 궁극적인 목표입니다.

웹 접근성 개선에는 다양한 방법이 있습니다. 우선, **단순하고 명확한 HTML 구조**와 **시맨틱 태그**가 필요합니다. 여기서, 시맨틱 태그는 웹 페이지의 구조와 의미를 명확하게 전달해 스크린 리더가 콘텐츠를 쉽게 이해하도록 도와줍니다.

또한, **ARIA 속성을 활용**하여 스크린 리더가 동적 콘텐츠나 복잡한 UI 요소를 올바르게 인식할 수 있게 만들 수 있습니다.

마지막으로, **키보드로도 페이지를 탐색할 수 있도록 포커스를 명확히 지정**하여 키보드 사용자가 필요한 정보에 접근하기 쉽게 해야 합니다.

이러한 웹 접근성 개선을 통해서 장애가 있는 사용자를 포함한 모든 사용자들에게 더 나은 사용자 경험을 제공할 수 있습니다.

### **말씀해주신 방법으로 개선하면 웹 접근성은 완벽해지는 건가요?**

모든 장애 유형을 완벽히 대응하는 것은 현실적으로 어렵습니다. 장애마다 고려해야 할 요소가 다르고, 이를 100% 만족시키는 것이 어렵기 때문입니다. 따라서, **단순히 많은 항목을 충족하는 데 매몰되기보다는, 우리 서비스에서 각 장애 유형 별로 사용자가 어떤 경험을 하고 있는지 파악**하는 것이 중요합니다. 예를 들면, 스크린 리더로 탐색해보며 시각 장애 사용자가 어떤 경험을 하고 있는지 파악할 수 있습니다. 이러한 정보를 기반으로 우선순위를 정렬하고, 기업의 상황에 맞게 점진적으로 접근성을 개선해 나가는 것이 지속 가능하고 현실적인 방식일 것입니다.

</details>
<br/>

<details>
<summary> SSR(Server Side Rendering)에 대해 설명해주세요.
 </summary>
<br/>
**SSR(Server Side Rendering)** 방식은 **초기 화면을 클라이언트가 아닌 서버에서 렌더링하여 완성된 HTML을 클라이언트에 내려주는 방식**입니다. SSR에서는 서버 단에서 HTML을 완성해 클라이언트에 전송하고, 클라이언트가 해당 HTML을 파싱만 하여 화면을 그리는 방식입니다. 경우에 따라서는, 이후 Hydration을 통해 이벤트 리스너 부착 등의 자바스크립트 작업을 수행하여 정적인 화면을 동적으로 전환합니다.

반면, **CSR(Client Side Rendering)** 방식에서는 **브라우저가 서버로부터 비어있는 뼈대 HTML을 받아온 후, 필요한 자바스크립트 번들을 다운로드하고 번들을 실행하여 동적으로 컨텐츠를 채웁니다**.

### **SSR의 장점은 무엇인가요?**

**SEO(검색 엔진 최적화)** 측면에서 유리합니다. 화면이 동적으로 그려지는 CSR에 비해서 검색 엔진이 크롤링할 때 더 쉽게 컨텐츠를 인식할 수 있기 때문입니다. 이런 점에서 SSR은 블로그나 커머스 등 SEO가 중요한 웹 애플리케이션에 특히 적합합니다.

또한, SSR 방식에서는 사용자가 **빠른 초기 로딩 속도**를 경험할 수 있습니다. CSR과 달리 SSR에서는 번들을 다운로드 받을 필요가 없고, 번들을 실행하여 동적으로 화면을 그려야 할 필요도 없기 때문입니다.

### **SSR의 단점은 없나요?**

물론 SSR에도 단점이 존재합니다.

첫째, **상호작용 초기화가 느립니다**. 이는 페이지가 표시되기까지 걸리는 시간(TTV)과 상호작용까지 걸리는 시간(TTI) 사이에 격차가 발생한다는 의미입니다. 그 사이에 사용자가 버튼을 클릭해도 동작하지 않는 등의 답답한 상황을 겪을 수 있습니다.

둘째, 상대적으로 **구현 난이도가 높습니다**. 자바스크립트 번들로 대부분의 작업이 수행되는 CSR에 비해서 SSR은 과정이 복잡하기 때문입니다.

마지막으로, **서버 비용이 증가합니다**. 정적인 파일을 내려주기만 하면 되는 CSR과 달리, 동적으로 HTML을 생성하기 위해 WAS 서버를 구동해야 하기 때문입니다.

</details>
<br/>

<details>
<summary>😊 시맨틱 마크업이란 무엇이며, 왜 중요한가요?
 </summary>
<br/>
시맨틱 마크업은 HTML 요소를 사용하는 방식으로, 단순히 시각적 목적이 아닌 요소의 의미를 잘 나타내도록 작성하는 방식을 말합니다. 예를 들어, <div>와 <span> 같은 비시맨틱 태그가 아닌, <header>, <footer>, <article>, <section> 같은 시맨틱 태그를 사용하여 문서 구조와 콘텐츠의 역할을 명확하게 하는 것입니다.
시맨틱 마크업이 중요한 이유는 크게 두 가지입니다.
첫째, 접근성을 개선하기 위함입니다. 시맨틱 요소들은 스크린 리더와 같은 접근성 도구에서 콘텐츠의 구조를 더욱 잘 해석할 수 있게 해 주어 시각장애인이나 노인 등 다양한 사용자층이 사이트를 효과적으로 탐색할 수 있게 합니다. 이러한 요소를 올바르게 사용하면, 더 많은 사람들에게 접근 가능한 웹 환경을 제공할 수 있습니다.
둘째, SEO(검색 엔진 최적화)에 유리합니다. 검색 엔진은 HTML의 시맨틱 구조를 통해 페이지의 구성을 파악합니다. 그렇기에 시맨틱 마크업을 적절히 적용하면, 검색 엔진이 페이지를 올바르게 파악할 수 있고, 그에 따라 검색 결과에서 페이지가 더 잘 노출될 가능성이 높아집니다.
따라서 시맨틱 마크업은 단순한 코드 작성 컨벤션을 넘어, 웹 접근성과 SEO를 위한 중요한 요소로, 현대 웹 개발에서 필수적인 기술이라고 할 수 있습니다.
CSR(Client Side Rendering)에서도 시맨틱 마크업이 SEO에 영향을 미친다고 보시나요? 만약 그렇다면, 왜 그렇다고 생각하시나요?
CSR 환경에서는 시맨틱 마크업이 SEO에 주는 영향이 다소 제한적일 수 있지만, 여전히 중요한 역할을 한다고 생각합니다.
CSR에서는 대부분의 콘텐츠가 클라이언트 측에서 렌더링되기 때문에, 검색 엔진이 페이지를 크롤링할 때 페이지의 초기 콘텐츠만 인식할 가능성이 큽니다. 그렇더라도 최근 검색 엔진들은 JavaScript 렌더링을 지원하는 방향으로 진화하고 있으며, 페이지의 시맨틱 구조를 어느 정도 파악할 수 있습니다. 따라서 시맨틱 마크업을 제대로 적용하면 CSR에서도 검색 엔진이 콘텐츠의 중요한 부분을 더 쉽게 인식하게 되어 검색 결과에 긍정적인 영향을 미칠 수 있습니다.

</details>
<br/>
