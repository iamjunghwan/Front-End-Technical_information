<details>
<summary>reflow와 repaint의 차이점에 대해서 설명해주세요.</summary>
<br/>
reflow와 repaint는 웹 페이지가 렌더링 되는 과정에서 발생하는 중요한 작업들입니다.
먼저, reflow에 관해 설명하겠습니다. reflow는 브라우저가 페이지의 레이아웃을 다시 계산하는 과정을 말합니다. DOM의 구조가 변경되거나 CSS 스타일이 변경되면, 브라우저는 각 요소가 화면에 어떻게 배치될지 다시 계산해야 합니다. 이 과정은 모든 자식 요소와 관련된 부모 요소까지 영향을 주기 때문에 비용이 많이 드는 작업입니다. 예를 들어, CSS에서 요소의 width나 height 속성을 변경하면, 브라우저는 해당 요소뿐만 아니라 연관된 모든 요소의 배치를 다시 계산해야 합니다.
반면에, repaint는 요소의 모양이나 스타일이 변경될 때 발생합니다. 요소의 레이아웃은 그대로이고, 색상이나 배경 등의 스타일만 변경되는 경우를 말합니다. background-color 같은 속성을 예로 들 수 있습니다. 이 경우 브라우저는 요소의 모양만 다시 그리면 되기 때문에 reflow보다는 비용이 덜 들지만, 여전히 성능에 영향을 줄 수 있습니다.
reflow는 레이아웃을 다시 계산하는 과정이고, repaint는 그 계산 결과를 화면에 다시 그리는 과정이라고 할 수 있습니다. 이 둘을 잘 이해하고 관리한다면 성능 최적화에 큰 도움이 됩니다.
둘을 잘 관리하는 것이 성능 최적화에 도움이 된다고 하셨는데, 최적화 방법에는 무엇이 있을까요?
최적화하는 데에 여러 가지 방법이 있는데요. 크게 3가지 정도 말씀드려볼 수 있을 거 같습니다.
첫 번째로 reflow를 유발하는 CSS 속성 사용을 최소화하는 것입니다.
width, height, margin, padding, border 등의 속성은 요소의 레이아웃을 다시 계산하게 하므로 reflow를 일으킵니다. 가능한 한 미리 CSS에서 스타일을 설정해 초기 로드 시에만 계산이 이루어지도록 하고, 이후에는 변경하지 않는 것이 좋습니다.
두 번째로 CSS 애니메이션 최적화입니다. 애니메이션에 transform과 opacity 속성만을 사용하는 것이 성능에 유리합니다. 이 두 속성은 GPU 가속을 사용할 수 있어 reflow를 일으키지 않고 repaint만 발생시키므로 CPU 자원을 적게 사용합니다.
마지막으로 will-change 속성 사용입니다. CSS의 will-change 속성을 사용하여 브라우저에 특정 요소가 변경될 것이라고 미리 언질을 줄 수 있습니다. 예를 들어, will-change: transform으로 미리 GPU에서 요소를 준비하게 하여 reflow 및 repaint에 미치는 영향을 줄일 수 있습니다. 하지만 will-change 속성은 너무 자주 사용하면 메모리 낭비가 발생하므로 필요한 요소에만 적용해야 한다는 주의점 또한 존재합니다.

</details>
<br/>

<details>
<summary>브라우저 렌더링 파이프라인에 대해서 설명해주세요.   </summary>
<br/>
브라우저가 웹 페이지를 화면에 표시하기 위해 거치는 과정을 브라우저 렌더링 파이프라인이라고 합니다. 이 과정은 크게 5단계로 나눌 수 있습니다.

### 첫번째로 **DOM 생성**입니다.

브라우저가 HTML 파일을 받으면, 이 파일을 바이트(byte) 단위로 읽기 시작합니다. 브라우저의 HTML 파서(Parser)는 이 바이트들을 문자(character)로 변환하고, 이 문자들을 다시 HTML 토큰으로 변환합니다. 이 HTML 토큰들은 각각의 태그와 그 안에 포함된 텍스트, 속성 등을 의미하게 됩니다.

HTML 토큰이 생성되면, 브라우저는 이를 기반으로 **DOM 트리**를 생성합니다. **DOM 트리**는 HTML 문서의 구조를 트리 형태로 표현한 것으로, 각 태그가 노드(node)가 되어 부모-자식 관계를 형성합니다. 예를 들어, `<body>` 태그 아래에 `<div>`가 있다면, DOM 트리에서도 `<body>` 노드 아래에 `<div>` 노드가 있게 됩니다.

### 두번째로 **CSSOM 생성**입니다.

브라우저는 CSS 파일을 파싱(parse)합니다. CSS 파일 역시 바이트로 전송되므로, 브라우저는 이를 문자로 변환한 뒤, CSS 규칙으로 나눕니다. 각 CSS 규칙은 `선택자(selector)`와 `선언(declaration)`으로 구성되는데, 선택자는 스타일을 적용할 HTML 요소를 정의하고, 선언은 적용할 스타일을 정의합니다.

브라우저는 이 CSS 규칙들을 기반으로 **CSSOM 트리**를 생성합니다. CSSOM 트리는 DOM과 유사하게 트리 구조를 가지며, 각 노드는 해당 노드에 적용될 스타일 정보를 포함합니다.

### 세번째로 **렌더 트리 생성**입니다.

이제 브라우저는 DOM과 CSSOM을 결합하여 **렌더 트리**를 생성합니다. 렌더 트리는 화면에 실제로 표시될 요소들로만 구성됩니다. 예를 들어 display: none 속성이 있는 요소는 렌더 트리에 포함되지 않습니다. 이는 렌더 트리가 실제로 화면에 그려질 요소들만을 포함하기 때문입니다.

렌더 트리의 각 노드는 DOM 트리의 요소와 연결되며, CSSOM 트리에서 해당 요소에 적용된 스타일 정보를 포함합니다. 즉, 렌더 트리는 HTML 문서의 구조와 각 요소의 스타일 정보를 모두 포함한 트리입니다.

### 네번째로 **레이아웃**입니다.

렌더 트리가 생성된 후, 브라우저는 이 트리를 사용해 각 요소의 정확한 위치와 크기를 계산합니다. 이 과정이 바로 레이아웃(Layout)입니다. 레이아웃 과정에서는 렌더 트리의 각 노드가 화면의 어디에 위치할지, 그리고 얼마나 큰지를 계산하게 됩니다.

이 계산은 화면의 뷰포트(viewport) 크기와 같은 정보에 의존합니다. 예를 들어, 화면 크기가 변경되면 브라우저는 레이아웃 과정을 다시 수행해야 합니다. 이 과정을 흔히 '리플로우(Reflow)'라고 부르는데, 리플로우는 성능에 영향을 줄 수 있으므로 이를 최소화하는 것이 중요합니다.

### 다섯번째로 **페인팅**입니다.

레이아웃이 완료되면, 브라우저는 각 요소를 실제로 화면에 그리는 작업을 시작합니다. 이 과정을 페인팅이라고 합니다. 페인팅 단계에서는 텍스트, 색상, 그림자, 이미지 등 모든 시각적 요소가 화면에 그려집니다.

페인팅은 화면에 표시될 그래픽 요소를 생성하는 과정이기 때문에, 이 과정도 성능에 큰 영향을 줄 수 있습니다. 특히, 복잡한 그래픽이나 애니메이션이 포함된 경우 페인트 작업이 많아져 성능이 저하될 수 있습니다.

### 마지막 단계는 **컴포지팅**입니다.

브라우저는 화면에 그려질 요소들을 각각의 레이어(layer)로 분리하고, 이 레이어들을 결합하여 최종 화면을 구성합니다. 이 과정에서는 GPU를 활용하여 각 레이어를 빠르게 합성합니다.

transform과 opacity와 같은 속성은 레이아웃이나 페인트 과정을 거치지 않고, 이 컴포지팅 단계에서만 처리됩니다. 이 덕분에 이러한 속성을 사용하는 애니메이션은 더 부드럽고 빠르게 실행될 수 있습니다. 컴포지팅 단계는 GPU 가속을 활용하여 성능을 최적화하고, 화면에 최종적으로 표시되는 결과를 빠르게 생성하는 데 중요한 역할을 합니다.

</details>
<br/>

<details>
<summary>인터넷 창에 www.google.com를 입력하면 무슨 일이 일어나는지 설명해주세요.   </summary>
<br/>
첫번째로 **DNS 조회**가 일어납니다. 사용자가 "[www.google.com"을](http://www.google.xn--com"-jy1s/) 입력하면, 브라우저는 먼저 이 도메인 이름을 IP 주소로 변환해야 합니다. 이 과정을 DNS 조회(DNS Lookup)라고 합니다. 브라우저는 캐시된 DNS 기록을 먼저 확인하고, 없으면 로컬 DNS 서버에 요청하여 "[www.google.com"에](http://www.google.xn--com"-eg0s/) 해당하는 IP 주소를 얻습니다.

두번째로 **TCP 연결 수립**입니다. IP 주소가 확인되면, 브라우저는 서버와 TCP 연결을 수립합니다. TCP(Transmission Control Protocol)는 데이터를 신뢰성 있게 전달하기 위한 프로토콜입니다. 이 과정에서 브라우저는 서버와 3-way handshake를 수행합니다. 즉, 브라우저가 SYN 패킷을 보내고, 서버가 SYN-ACK 패킷을 보내며, 다시 브라우저가 ACK 패킷을 보내는 과정입니다.

세번째로 **HTTP 요청**입니다. TCP 연결이 수립되면, 브라우저는 HTTP 또는 HTTPS 요청을 보냅니다. 이 요청은 "GET / HTTP/1.1" 같은 형식으로, 웹 페이지를 요청하는 메시지입니다. HTTPS를 사용할 경우, 이 단계에서 SSL/TLS 핸드셰이크도 수행됩니다. 이 과정에서는 브라우저와 서버가 암호화된 연결을 설정하기 위해 보안 인증서를 교환하고, 암호화 키를 협상합니다.

네번째로 **서버의 응답**을 받습니다. 서버는 요청을 받고, 해당 리소스(HTML, CSS, JavaScript, 이미지 등)를 브라우저에게 응답으로 보냅니다. 이 응답은 HTTP 응답 코드(예: 200 OK)와 함께 전달됩니다.

마지막으로 받은 리소스들을 바탕으로 **브라우저 렌더링 파이프라인을 진행**합니다. DOM과 CSSOM을 생성하고, 렌더 트리를 구성한 뒤, 레이아웃과 페인트 단계를 통해 웹 페이지가 화면에 표시됩니다.

</details>
<br/>
