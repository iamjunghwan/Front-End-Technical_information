<details>
<summary>😊 타입스크립트의 타입과 인터페이스의 차이점을 설명해주세요.
 </summary>
<br/>
**interface**는 **객체의 형태를 확장**하는 데 용이한 반면, **type**은 튜플, 인터섹션, 유니온 등을 이용하여 더 **복잡한 타입 정의 및 조합을 표현**하는 데 용이합니다.

먼저, **interface**는 선언 병합을 지원해 여러 번 선언할 수 있어, 주로 객체 타입을 **확장**할 때 유리합니다. 동일한 이름을 가진 interface를 여러 번 선언하면, 이 속성들이 자동으로 합쳐집니다. 예를 들면 다음과 같습니다.

```
interface Person {
  age: number;
  name: string;
  isBirthday: boolean;
}

interface Person {
  address: string;
}

const person1: Person = {
  age: 1,
  name: "abcd",
  isBirthday: false,
  address: "1010",
};

```

위 코드에서 Person interface를 여러 번 선언할 수 있으며, 결과적으로 하나의 interface로 병합됩니다.

반면, **type**으로 선언한 경우에는 동일한 이름을 중복 선언하면 에러가 발생합니다. 대신, **type**은 튜플과 같은 **복잡한 타입 표현**이 가능하며, **복잡한 타입 조합**을 위해 인터섹션(&)과 유니온(|) 연산자를 지원합니다.

예를 들어, type을 이용해 여러 타입을 조합하는 방식은 다음과 같습니다.

```
type BasicInfo = {
  name: string;
  age: number;
};

type ContactInfo = {
  email: string;
  phone: string;
};

// 인터섹션 타입 (&)을 사용해 두 타입을 결합하여 하나의 타입으로 생성
type PersonInfo = BasicInfo & ContactInfo;

const person2: PersonInfo = {
  name: "John",
  age: 30,
  email: "john@example.com",
  phone: "123-456-7890",
};

```

정리하자면, **interface**는 선언 병합을 통해 여러 번 선언이 가능하여 주로 객체 타입을 **확장**하는 데 유리하며, **type**은 튜플 등 복잡한 타입을 사용하고 유연한 연산자를 통해 복잡한 타입 조합을 **표현**하는 데 적합합니다.

</details>
<br/>

<details>
<summary>
✋ 타입스크립트를 사용하는 이유를 설명해주세요.
 </summary>
<br/>
첫째, **정적 타이핑을 통해 코드의 안정성을 크게 향상**시킬 수 있습니다. 개발 시 타입 오류를 런타임으로 실행하기 이전에 발견할 수 있어 런타임 에러를 줄이고, 코드의 품질을 개선할 수 있습니다. 이러한 장점은 특히 대규모 프로젝트에서 두드러집니다.

둘째, **개발자의 생산성을 높여줍니다**. IDE의 자동완성 기능과 인텔리센스가 더 많은 정보를 제공할 수 있게 되기 때문에 코드 작성 속도가 빨라지고, 리팩토링이 쉬워집니다. 또한 명시적인 타입 정의가 마치 문서화의 역할을 하여 코드의 가독성과 이해도가 높아집니다.

셋째, **객체지향 프로그래밍의 일부 기능을 자바스크립트에 추가**합니다. 인터페이스, 제네릭, 열거형 등 현대적인 프로그래밍 패러다임을 지원하여 더욱 구조화되고 확장 가능한 코드를 작성할 수 있습니다.

정리하면 타입스크립트는 자바스크립트의 한계를 극복하고, 안정성, 생산성, 기능성 을 향상시키는 데 큰 도움이 됩니다.

## **타입스크립트를 도입하지 않는 것이 더 나은 경우도 있나요?**

타입스크립트를 도입하지 않는 것이 더 적합한 프로젝트는 주로 **개발 속도**와 **간단함**이 중요한 소규모 프로젝트입니다. 예를 들어, **프로토타입 제작**이나 **단순한 랜딩 페이지**처럼 빠른 개발 주기가 요구되고 복잡한 로직이 없는 경우, 타입스크립트를 설정하고 사용하는 것이 오히려 과도한 비용이 될 수 있습니다.

또한, 팀 내에 **타입스크립트에 대한 경험이 부족하거나 러닝 커브를 극복할 시간이 없는 경우**에도 도입을 신중히 고려해야 합니다. 타입스크립트는 초기 설정과 코드 작성이 더 엄격하기 때문에, 팀이 익숙하지 않다면 생산성이 오히려 저하될 수 있습니다.

마지막으로, **기존 자바스크립트 프로젝트가 매우 방대하고, 타입스크립트로 전환하는 데 드는 비용이나 리소스를 감당할 수 없는 경우**에도 도입이 적합하지 않을 수 있습니다. 이런 경우, 점진적 도입 또는 순수 자바스크립트를 유지하면서 코드 리뷰와 테스트 강화로 대안을 마련할 수 있습니다.

## **타입스크립트를 새롭게 도입하는 것을 추진할 때, 팀원들을 어떻게 설득하실 건가요?**

타입스크립트의 장점과 실질적 이점을 명확히 전달하는 것이 중요하다고 생각합니다. 먼저, **타입스크립트가 런타임 에러를 줄이고 코드 안정성을 강화한다**는 점을 강조할 것입니다. 특히, 유지보수 비용이 큰 프로젝트나 복잡한 코드베이스가 있는 상황이라면, 타입 시스템이 협업과 코드 품질을 어떻게 개선할 수 있는지 실제 사례를 통해 차이점을 보여줄 것입니다.

다음으로, **초기 학습 곡선과 도입에 대한 부담을 완화할 수 있는 점진적 도입 전략**을 제안할 것 같습니다. 예를 들어, 신규 코드에만 타입스크립트를 부분 도입하거나, 주요 모듈에 한정해 적용하는 방법을 제안해볼 것 같습니다. 또한, 팀이 학습에 부담을 느끼지 않도록 공식 문서, 타입스크립트 핸드북, 그리고 교육 자료를 제공하여 점진적으로 학습할 수 있는 여건이 마련되도록 노력할 것입니다.

</details>
<br/>

<details>
<summary>🥶 타입 단언이란 무엇이며 언제 사용하나요?</summary>
<br/>
쉽게 설명하면, **타입 단언(Type Assertion)은 컴파일러에게 특정 값이 어떤 타입인지 개발자가 더 잘 알고 있다고 알려주는 방법**입니다. 개발자가 `as`를 이용해 타입을 단언하면, 자동 추론된 타입을 덮어쓰게 됩니다. 이는 컴파일러가 타입을 자동으로 추론하지 못하거나 잘못 추론하는 상황에서 사용됩니다.

예를 들어, DOM 요소를 가져오는 `document.getElementById()` 메서드의 반환 타입은 `HTMLElement | null`로 정의되어 있습니다. 하지만 개발자가 해당 요소가 `HTMLDivElement`임을 확신한다면, `as HTMLDivElement`를 사용해 컴파일러에게 명시적으로 알려줄 수 있습니다. 이를 통해 타입 오류 없이 안전하게 속성에 접근할 수 있습니다.

```
const element = document.getElementById("myElement") as HTMLDivElement;

element.style.backgroundColor = "blue";

```

타입 단언은 주로 **API나 외부 라이브러리의 반환 타입을 확실히 알고 있을 때** 사용됩니다. 컴파일러가 타입 추론에 실패하거나 경고를 발생시키는 경우에 타입 단언을 통해 올바른 타입을 지정할 수 있습니다.

## **타입 단언을 사용할 때 주의할 점은 무엇인가요? 🤔**

타입 단언은 **컴파일러의 타입 검사를 우회하기 때문에, 실제 값이 단언한 타입과 다를 경우 런타임 에러가 발생할 수 있습니다**. 따라서 타입 단언은 해당 타입을 확실히 알고 있을 때만 사용하는 것이 중요하며, 가능한 한 타입 추론과 타입 가드를 우선적으로 사용하는 것이 바람직합니다. 잘못된 사용은 타입스크립트의 장점을 훼손하며, 오히려 코드의 안정성을 해칠 수 있습니다.

## **타입 단언을 더 안전하게 활용하기 위한 원칙이 있나요? 🧐**

첫째로, **타입 단언보다는 타입 내로잉(narrowing)을 우선적으로 활용하는 것이 좋습니다**. 타입스크립트는 조건문과 타입 체크를 통해 자동으로 타입을 좁힐 수 있으므로, 가능한 한 단언 없이 타입을 명확히 하는 방식이 권장됩니다.

```
function printLength(value: string | string[]) {
  if (Array.isArray(value)) {
    console.log(value.length); // 타입 내로잉으로 배열로 안전하게 처리
  } else {
    // 문자열로 처리
  }
}

```

또한, **type predicate을 활용한 타입 가드를 통해서도 타입 안전성을 높일 수 있습니다**. type predicate을 통해 데이터 구조를 확인하여 런타임 오류를 줄이는 방식입니다.

```
function isFish(pet: Fish | Bird): pet is Fish {
    return (pet as Fish).swim !== undefined;
}

if (isFish(pet)) {
    pet.swim();
}

```

마지막으로, **타입 단언은 최소한의 범위에서만 사용하는 것이 좋습니다**. 전체 객체보다는 필요한 속성이나 특정 부분만 단언하는 방식으로 불필요한 위험을 줄이는 것이 바람직합니다.

```
const element = document.getElementById("myElement");
if (element) {
  (element as HTMLDivElement).style.backgroundColor = "blue"; // 필요한 부분만 단언
}
```

</details>
<br/>
