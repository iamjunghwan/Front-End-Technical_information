<details>
<summary>🐸 이미지 크기가 클 경우 렌더링 속도가 느려질 텐데, 이를 개선하기 위한 방법들을 설명해주세요.
 </summary>
<br/>
크게 세 가지의 방법을 말씀드릴 수 있습니다.

첫째, **이미지 포맷 최적화**입니다. 전통적인 JPEG나 PNG 대신, 압축 효율이 높은 WebP 또는 AVIF와 같은 최신 포맷으로 변환할 수 있습니다. 이 포맷들은 이미지 품질을 유지하면서도 파일 크기를 크게 줄여줍니다. 단, 일부 구버전의 브라우저에서는 최신 이미지 포맷을 지원하지 않지 않으므로, 호환성을 고려할 필요가 있습니다.

둘째, **이미지 사이즈 조정**입니다. 화면에 노출되는 크기에 비해 이미지가 과도하게 큰 경우 이미지를 작게 리사이징할 수 있습니다. 필요한 크기에 맞게 잘라 서버에서 내려줄 수 있습니다. 또한, 다양한 디바이스 해상도에 대응하기 위해 Responsive Images 기술, 즉 `srcset`과 `sizes` 속성을 활용할 수 있습니다. 이 경우, 브라우저가 현재 화면 크기에 최적화된 이미지를 선택하여 로드할 수 있습니다.

셋째, **지연 로딩(Lazy Loading**)입니다. 사용자가 화면에 스크롤할 때 해당 위치에 도달하는 이미지가 로드되도록 설정하는 방법입니다. 지연 로딩을 통해 초기 로딩 속도를 개선할 수 있습니다. HTML `loading="lazy"` 속성을 통해 구현할 수 있으며, 이를 통해 불필요한 이미지 로드를 방지할 수 있습니다.

마지막으로, **CDN(Content Delivery Network**)입니다. CDN을 적용하면 사용자가 지리적으로 가까운 서버에서 이미지를 다운로드하게 되어 로딩 속도를 단축시킬 수 있습니다.

이러한 방법을 상황에 맞게 적용하면 이미지 로딩 속도를 향상시켜 사용자 경험을 크게 개선할 수 있습니다.

### **WebP나 AVIF는 모든 브라우저에서 지원하지 않는다고 하셨는데, 호환성 문제를 어떻게 해결할 수 있을까요?**

호환성 문제에 대비하기 위해 **HTML의 `<picture>` 요소를 통해 fallback 이미지를 적용**할 수 있습니다. `<picture>` 요소 내부에 WebP나 AVIF와 같은 고효율 포맷을 우선 설정하고, 브라우저가 이를 지원하지 않을 경우 JPEG나 PNG와 같은 기본 포맷을 로드하도록 할 수 있습니다.

구체적인 예시는 아래와 같습니다.

```html
<picture
  ><source srcset="image.avif" type="image/avif" />
  <source srcset="image.webp" type="image/webp" />
  <img src="image.jpg" alt="Image description"
/></picture>
```

이 코드에서 브라우저는 AVIF를 우선 시도하고, 지원하지 않으면 WebP를, 둘 다 지원하지 않으면 마지막 img 태그의 jpg 이미지를 로드하게 됩니다.

</details>
<br/>

<details>
<summary>🤣 낙관적 업데이트에 관하여 설명해주세요.
 </summary>
<br/>
**낙관적 업데이트**는 **성공적인 상태 업데이트가 이뤄질 거라는 가정 하에 서버 응답 이전에 UI를 미리 업데이트하는 방법**입니다. 사용자 요청을 서버가 성공적으로 처리할 거라고 미리 예상하고, UI를 즉각적으로 변경해서 사용자에게 **빠른 반응**을 보여줍니다.

낙관적 업데이트의 대표적인 예시로 **좋아요 기능**을 들 수 있습니다. 예를 들어, 사용자가 좋아요 버튼을 클릭하면 서버 응답을 기다리지 않고, 화면에 바로 좋아요 클릭에 대한 상태를 보여주는 것입니다. 서버 응답이 성공적으로 돌아오면 그대로 두고, 혹시나 실패하면 UI에서 해당 좋아요 상태를 다시 해제하거나 오류 메시지를 보여주는 방식입니다.

**낙관적 업데이트의 장점**은, 서버 응답 속도와 관계 없이 즉각적인 피드백을 제공해서 사용자들이 시스템을 빠르게 쓸 수 있다는 점입니다. 특히 네트워크 상태가 좋지 않거나 응답 시간이 길어도 사용자 경험에는 영향을 덜 미치게 됩니다.

다만, 서버에서 오류가 발생하면 잠시동안 화면에 잘못된 정보가 표시될 수 있습니다. 따라서 이 경우를 대비한 오류 핸들링(롤백) 로직을 같이 설계해야 하는 주의점이 있습니다.

## **좋은 사용성을 위해서는 낙관적 업데이트를 가능한 한 많이 적용하는 것이 좋겠네요?**

많은 곳에 낙관적 업데이트를 적용하는 게 항상 좋은 건 아닙니다. 낙관적 업데이트는 **요청이 성공할 가능성이 높고, 사용자 경험을 즉시 개선하는 데 큰 장점이 있을 때** 사용하는 게 적합합니다.

예를 들어 결제나 거래 내역과 같이 중요한 데이터를 다루는 경우에는 낙관적 업데이트가 오히려 사용자 경험을 저해할 수 있습니다. 낙관적 업데이트를 적용했을 때, **요청에 실패한다면 민감도 높은 정보가 순간적으로 잘못 표시**되면서 사용자 경험을 크게 저해할 수 있기 때문입니다.

또한 **네트워크 환경이 불안정한 경우에는 요청에 대한 실패율이 높아지기 때문에 잦은 롤백**이 발생할 수 있습니다. 이 경우 역시 사용자 경험을 저해할 수 있기 때문에 오히려 서버 응답을 기다리는 것이 더 나은 판단일 수 있습니다.

</details>
<br/>

<details>
<summary>✅ 리액트에서 컴포넌트가 불필요하게 리렌더링되는 상황을 방지하기 위한 방법을 설명해 주세요.
 </summary>
<br/>
React에서 불필요한 리렌더링을 방지하는 방법에 대해 설명드리겠습니다.

첫째, **React.memo**를 활용하여 컴포넌트를 메모이제이션할 수 있습니다. 이는 컴포넌트의 props가 변경되지 않으면 컴포넌트를 리렌더링하지 않도록 합니다. 특히 부모 컴포넌트가 자주 업데이트되는 상황에서 유용합니다.

```
const MemoizedComponent = React.memo(MyComponent);

```

둘째, **useMemo**와 **useCallback** 훅을 사용하여 각각 값과 함수를 메모이제이션할 수 있습니다. `useMemo`는 계산 비용이 많이 드는 연산 결과를, `useCallback`은 자식 컴포넌트에 전달되는 콜백 함수를 메모이제이션합니다.

```
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
const memoizedCallback = useCallback(() => doSomething(a, b), [a, b]);

```

마지막으로, **React DevTools의 Profiler**를 활용하여 불필요한 리렌더링이 발생하는 컴포넌트를 식별하고 최적화할 수 있습니다.

이러한 최적화는 성능 문제가 실제로 발생할 때 적용하는 것이 좋으며, 과도한 최적화는 코드의 복잡성을 증가시킬 수 있다는 점을 항상 고려해야 합니다.

## **useCallback과 useMemo와 같은 메모이제이션은 되도록 많은 곳에 적용할수록 성능이 좋아지나요?**

**아니요, 메모이제이션을 무분별하게 적용하는 것은 오히려 성능에 부정적인 영향을 미칠 수 있습니다. 메모이제이션도 결국 또다른 비용이 발생하는 작업이기 때문입니다. React는 이전 값을 메모리에 저장해야 하므로 메모리 비용이 발생하고, 의존성 배열의 각 항목을 비교하는 작업을 수행해야 하기도 합니다.**

```jsx
// 이런 간단한 함수의 경우 메모이제이션이 오히려 불필요합니다.
const handleClick = useCallback(() => {
  console.log("clicked");
}, []);

// 반면, 복잡한 연산의 경우 메모이제이션이 효율적입니다.
const expensiveValue = useMemo(() => {
  return complexCalculation(items);
}, [items]);
```

복잡한 계산이 필요한 경우, 컴포넌트가 자주 리렌더링되는 경우 등 성능 최적화가 필요한 경우에만 메모이제이션이 성능에 도움이 됩니다. 따라서 성능 최적화는 실제 병목이 발생하는 지점을 React DevTools Profiler로 확인하고, 선별적으로 적용하는 것이 바람직합니다.

</details>
<br/>

<details>
<summary>
🧶 webpack, rollup과 같은 번들러는 왜 필요한지 설명해주세요.
 </summary>
<br/>
**번들러**는 **다양한 파일과 모듈을 하나의 배포 가능한 번들로 묶는 역할**을 합니다. 번들러가 필요한 주요 이유는 다음과 같습니다.

첫째, **네트워크 요청 성능을 개선**하기 위해서입니다. 다수의 개별 파일에 대해 모두 네트워크 요청을 수행할 경우, 성능에 부정적인 영향이 있을 수 있습니다. 번들러는 **다수의 파일을 하나 또는 소수의 파일로 묶어 네트워크 요청을 최적화**합니다. 예를 들어, 애플리케이션이 수백 개의 JavaScript, CSS, 이미지 파일을 사용한다면, HTTP 요청 수가 증가해 로딩 속도가 느려질 수 있습니다. 이때 번들러는 이들을 효율적으로 묶어 소수의 파일로 만듦으로써 네트워크 요청 수를 줄여줍니다.

둘째, **번들러는 트랜스파일링을 통해 더 효율적이고 호환성 있는 애플리케이션**을 만드는데 기여합니다. 먼저, **트랜스파일링을 통해 코드를 최적화**합니다. 예를 들어, `Dead Code Elimination`과 `Tree Shaking`과 같은 방법을 통해 사용되지 않는 코드와 불필요한 모듈을 제거해 번들 크기를 줄이고 로딩 성능을 개선합니다.

또한, 번들러는 **호환성을 높이기 위해 최신 JavaScript 문법과 기능을 구형 브라우저에서도 실행 가능하도록 변환**합니다. 예를 들어, ES6 이상의 모듈, 비동기 함수, 옵셔널 체이닝 같은 최신 기능은 지원하지 않는 브라우저에서 문제가 될 수 있는데, 번들러는 이를 ES5로 변환하여 호환성을 보장합니다. 이때 Babel 같은 트랜스파일러와 연계하여 처리하기도 합니다.

</details>
<br/>

<details>
<summary>📊 Progressive Partial Rendering(PPR)에 대해서 설명해주세요. </summary>
<br/>
Progressive Partial Rendering(PPR)은 웹 페이지의 로딩 성능을 최적화하는 기법으로, 페이지의 전체 콘텐츠를 한 번에 로딩하는 대신 중요도에 따라 콘텐츠를 단계적으로 로딩하는 방식입니다.

이 방법을 통해 사용자는 핵심 콘텐츠를 먼저 볼 수 있게 되어 체감 로딩 시간이 단축됩니다.

주요 기법으로는 서버 사이드 렌더링(SSR), 클라이언트 사이드 렌더링(CSR)을 혼합한 하이브리드 렌더링, 스트리밍 SSR, 점진적 하이드레이션 등이 있습니다.

이러한 PPR 기법들은 First Contentful Paint(FCP)와 Time To Interactive(TTI) 같은 성능 지표를 개선하는데 도움이 됩니다.

## Progressive Partial Rendering과 Lazy Loading의 차이점은 무엇인가요?🤔

Lazy Loading은 주로 뷰포트 밖에 있는 이미지나 컴포넌트와 같은 특정 리소스를 필요한 시점에 로드하는 기술입니다.

반면, Progressive Partial Rendering은 더 넓은 개념으로, 페이지의 핵심 콘텐츠를 먼저 렌더링하고 우선순위가 낮은 부분은 점진적으로 렌더링하는 전체적인 접근 방식입니다.

Lazy Loading은 Progressive Partial Rendering을 구현하는 기법 중 하나라고 볼 수 있습니다.

## Progressive Partial Rendering이 SEO에 미치는 영향은 무엇인가요? 🤔

Progressive Partial Rendering은 SEO에 긍정적인 영향을 미칠 수 있습니다. 핵심 콘텐츠가 더 빨리 로드되기 때문에 검색 엔진 크롤러가 중요한 콘텐츠를 더 효율적으로 색인화할 수 있습니다.

특히 서버 사이드 렌더링이나 하이브리드 접근 방식을 사용할 경우, HTML이 미리 렌더링되어 제공되므로 검색 엔진이 JavaScript를 실행하지 않고도 콘텐츠를 이해할 수 있어 유리합니다.

또한 Core Web Vitals 성능 지표가 SEO 순위에 영향을 미치는데, Progressive Partial Rendering은 LCP(Largest Contentful Paint), FID(First Input Delay), CLS(Cumulative Layout Shift) 같은 지표를 개선하는 데 도움이 됩니다.

</details>
<br/>
