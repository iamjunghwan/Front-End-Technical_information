<details>
<summary>😎 클로저에 대해서 설명해주세요</summary>
<br/>
클로저는 함수가 선언될 때의 스코프를 기억하여, 함수가 생성된 이후에도 그 스코프에 접근할 수 있는 기능을 말합니다. 비유하자면, 함수가 자신이 생성된 환경을 '기억'하는 것이라고 할 수 있습니다. 클로저는 자바스크립트의 함수가 일급 객체라는 특성과 렉시컬 스코프의 조합으로 만들어집니다.

예시와 함께 클로저의 동작을 설명드리면 좋을 것 같습니다.

**클로저 예시 코드**

```jsx
function outerFunction(outerVariable) {
  return function innerFunction(innerVariable) {
    console.log("Outer Variable: " + outerVariable);
    console.log("Inner Variable: " + innerVariable);
  };
}

const newFunction = outerFunction("outside");
newFunction("inside");
```

여기서 `innerFunction`은 `outerFunction`의 내부에 정의되어 있습니다. `innerFunction`은 자신이 생성된 스코프, 즉 `outerFunction`의 스코프를 기억하고, `outerFunction`의 호출이 완료된 이후에도 그 스코프에 접근할 수 있습니다. 그리고 이에 따라 `innerFunction`은 `outerVariable`에도 접근할 수 있습니다. 이것이 클로저가 동작하는 방식입니다.

## **클로저는 언제 활용하나요?**

클로저는 변수와 함수의 접근 범위를 제어하고 특정 데이터와 상태를 유지하기 위해 자주 활용됩니다. 크게 세 가지 대표적인 사용 사례로 나누어 설명드릴 수 있습니다.

첫째, 데이터 은닉에 활용됩니다. 클로저는 외부에서 접근할 수 없는 비공개 변수와 함수를 만들 수 있습니다. 이를 통해 데이터를 은닉하여 외부 접근을 막고, 데이터 무결성을 유지할 수 있습니다. 예를 들어, 특정 함수 내부에서만 접근 가능한 변수를 생성하고, 이를 조작할 수 있는 함수만 외부로 노출하여 안전하게 데이터를 관리할 수 있습니다.

둘째, 비동기 작업에 활용됩니다. 클로저는 비동기 작업에서 이전의 실행 컨텍스트를 유지해야 할 때 유용합니다. 콜백 함수가 비동기적으로 실행될 때 클로저를 사용하면 함수 실행 시점의 변수를 참조할 수 있습니다.

```
function createLogger(name) {
  return function() {
    console.log(`Logger: ${name}`);
  };
}

const logger = createLogger('MyApp');
setTimeout(logger, 1000); // 1초 후에 'Logger: MyApp' 출력

```

위의 예시에서 클로저가 `name` 변수(`'MyApp'`)를 저장하여 1초 후에도 해당 값이 유지되어 출력됩니다.

셋째, 모듈 패턴을 구현하는 데 활용됩니다. 모듈 패턴은 특정 기능을 캡슐화하고, 외부에 공개하고자 하는 부분만 선택적으로 노출하여 코드의 응집력을 높이고, 유지보수성을 향상시키는 패턴입니다. 클로저를 활용하면 필요한 함수와 데이터만 외부로 노출함으로써 모듈 패턴을 쉽게 구현할 수 있습니다.

</details>
<br/>

<details>
<summary>⛷️ 실행 컨텍스트에 대해서 설명해주세요. </summary>
<br/>
**실행 컨텍스트**는 자바스크립트에서 코드가 실행되는 환경을 의미합니다. 자바스크립트 엔진이 코드를 실행할 때, 그 코드가 실행될 때의 환경을 정의하고 관리하기 위해 존재하는 것이 실행 컨텍스트입니다.

실행 컨텍스트는 크게 **전역 실행 컨텍스트**와 **함수 실행 컨텍스트**로 나눌 수 있습니다.

**전역 실행 컨텍스트**는 자바스크립트가 처음 실행될 때 생성되는 컨텍스트입니다. 이 전역 컨텍스트는 프로그램이 종료될 때까지 유지되며, 전역에 선언된 변수나 함수가 모두 포함됩니다. 전역 컨텍스트에서 선언된 변수와 함수는 프로그램 내 어디서든 접근이 가능합니다.

기본적으로 자바스크립트는 싱글 스레드이기때문에, 전역 실행 컨텍스트는 1개만 존재합니다.

**함수 실행 컨텍스트**는 함수가 호출될 때마다 생성 되는 컨텍스트를 의미합니다. 각 함수는 자신만의 실행 컨텍스트를 가지며, 이 컨텍스트 내에서 선언된 변수와 함수는 해당 함수 내에서만 유효합니다. 함수가 종료되면 그 실행 컨텍스트도 함께 사라집니다.

## **실행 컨텍스트는 어떤 구성 요소로 이루어져 있나요?**

요약하면, 실행 컨텍스트는 `변수 객체`, `스코프 체인`, `this` 라는 구성요소로 이루어져 있습니다.

첫째, **변수객체**란 실행 컨텍스트 내에서 사용되는 변수와 함수 선언을 저장하는 공간입니다. 전역 컨텍스트에서는 전역 객체가 변수 객체의 역할을 하고, 함수 컨텍스트에서는 **활성화 객체**가 변수와 매개변수를 관리합니다.

두번째로는 **스코프 체인**입니다. 현재 실행 중인 컨텍스트와 외부 렉시컬 환경의 연결을 유지합니다. 변수를 참조할 때 현재 컨텍스트에서 찾지 못하면 외부 환경으로 범위를 넓혀가며 변수를 찾습니다.

마지막으로 **this**입니다. **this**는 실행 컨텍스트에 따라 참조하는 객체가 달라집니다. 전역 컨텍스트에서는 this가 전역 객체를 가리키며, 함수 컨텍스트에서는 함수 호출 방법에 따라 달라집니다.

실행 컨텍스트는 이러한 구성 요소를 바탕으로 자바스크립트 코드가 실행되는 동안의 환경을 관리하고, 코드 실행 시 변수의 유효 범위나 함수 호출의 맥락을 결정 짓습니다.

</details>
<br/>

<details>
<summary>🛒 이벤트 루프에 대해서 설명해주세요.</summary>
<br/>
자바스크립트의 **이벤트 루프**는 자바스크립트가 싱글 스레드 기반 언어임에도 불구하고 **비동기 작업을 처리할 수 있게 해주는** 중요한 메커니즘입니다.

자바스크립트는 기본적으로 한 번에 하나의 작업만 처리할 수 있습니다. 하지만 이벤트 루프가 **콜 스택**과 **태스크 큐**를 관리하면서 비동기 작업이 완료되면 그 결과를 처리할 수 있게 도와줍니다. 여기서, **콜 스택**은 현재 실행 중인 코드들이 쌓이는 곳이고, **태스크 큐**는 비동기 작업이 완료되면 그 결과를 대기시키는 곳입니다.

이벤트 루프의 동작을 설명하기 위해 간단한 예로 `setTimeout(callback, 0)`을 들어 보겠습니다. 자바스크립트 코드에서 `setTimeout(callback, 0)`을 호출하면, 이 콜백 함수는 바로 실행되는 것이 아니라 웹 API에 의해 타이머가 설정되고, 그 타이머가 0밀리초 후에 만료되면 콜백 함수가 태스크 큐에 추가됩니다. 그 후 콜 스택이 비어 있는 시점에 이벤트 루프가 태스크 큐에서 대기 중인 `callback`을 꺼내서 실행합니다.

따라서 `setTimeout(callback, 0)`을 호출해도 현재 실행 중인 모든 동기 작업들이 완료된 후에야 그 콜백이 실행됩니다. 이 때문에 `setTimeout(callback, 0)`을 사용하면 코드의 실행을 다음 이벤트 루프 사이클로 미뤄집니다.

이와 같이 **이벤트 루프**는 자바스크립트의 **비동기 작업**을 처리하는 데 있어서 매우 중요한 역할을 합니다. 이벤트 루프 덕분에 자바스크립트는 UI 업데이트나 사용자 입력 처리를 수행하면서도, 비동기 작업을 블로킹 없이 병렬적으로 처리할 수 있습니다.

## **앞서 말씀하신 태스크 큐의 종류에는 무엇이 있나요?**

태스크 큐는 **매크로태스크 큐**와 **마이크로태스크 큐**로 나뉩니다.

**매크로태스크 큐**는 `setTimeout`, `setInterval` 같은 일반적인 비동기 작업들이 대기하는 큐입니다. 매크로태스크 큐의 작업은 이벤트 루프가 콜 스택과 마이크로태스크 큐의 작업을 모두 처리한 후, 하나씩만 처리합니다.

**마이크로태스크 큐**는 `Promise.then()`과 같이 중요도가 높은 작업들이 대기하는 큐입니다. 마이크로태스크 큐는 매크로태스크 큐보다 우선순위가 높습니다. 이벤트 루프는 콜 스택이 비어있는 시점에 매크로태스크를 실행하기 이전에 마이크로태스크 큐에 있는 모든 작업들을 먼저 처리합니다.

이처럼 태스크 큐는 크게 `마이크로태스크 큐`와 `매크로태스크 큐`로 이뤄져 있으며, `마이크로태스크 큐` 작업은 `매크로태스크 큐` 작업보다 우선적으로 실행됩니다.

</details>
<br/>

<details>
<summary>🔥 자바스크립트 호이스팅에 대해서 설명해주세요. </summary>
<br/>
`호이스팅(Hoisting)`은 자바스크립트가 코드를 실행하기 전에 변수와 함수 선언을 코드의 최상단으로 끌어올리는 것처럼 동작하는 특징입니다. 이를 통해 코드의 선언된 위치와 관계없이 변수를 사용할 수 있는 것처럼 보일 수 있습니다.

하지만 호이스팅은 선언의 호이스팅일 뿐, 변수의 값 할당까지 끌어올려지지는 않습니다. 예를 들어 var로 선언된 변수는 선언 자체는 호이스팅되지만, 초기화되기 전까지는 undefined로 평가됩니다. 예시로는 다음과 같습니다.

```
console.log(myVar); // undefined

var myVar = 10;
console.log(myVar); // 10

```

함수 선언은 전체가 호이스팅되기 때문에, 함수 호출을 선언 이전에 해도 문제가 없습니다.

```
console.log(myFunction()); // 'Hello World' 출력

function myFunction() {
  return 'Hello World';
}

```

그러나 ES6에서 도입된 let과 const는 호이스팅이 되긴 하지만, 선언하기 전에 접근하려고 하면 ReferenceError가 발생합니다.

이는 `Temporal Dead Zone(TDZ)`이라는 개념 때문입니다. TDZ는 변수가 선언되었지만 초기화되기 전까지의 구간을 말합니다. let과 const로 선언된 변수는 TDZ가 존재하며, 이 구간에서는 변수에 접근할 수 없습니다.

```
console.log(myLet); // ReferenceError 발생

let myLet = 10;

```

이 경우, 변수 선언은 호이스팅되었지만 초기화는 변수 선언이 실제로 실행될 때까지 이루어지지 않습니다. TDZ는 코드에서 변수가 선언된 시점부터 초기화될 때까지의 구간에서 변수를 사용하지 못하게 막아주는 역할을 합니다.

따라서 호이스팅은 변수와 함수 선언을 코드 상단으로 끌어올리는 것처럼 동작하지만, var는 선언만 호이스팅되어 초기화 전에 undefined가 되며, let과 const는 TDZ로 인해 초기화 전에 접근하면 ReferenceError를 발생시킵니다.

</details>
<br/>

<details>
<summary>🎈 자바스크립트 배열에 대해서 설명해주세요. </summary>
<br/>
자바스크립트의 배열(Array)은 순서가 있는 리스트형 객체로, 여러 값을 하나의 자료구조에 저장할 수 있습니다.

배열은 제로 인덱스 기반으로, 배열의 각 값은 인덱스를 통해 접근할 수 있습니다. 자바스크립트 배열은 `동적 배열`로, 크기가 고정되어 있지 않고, 요소를 자유롭게 추가하거나 제거할 수 있는 유연성을 제공합니다.

배열의 선언은 간단하며, 다양한 데이터 타입을 함께 저장할 수 있습니다.

```
const array = [1, 'apple', true, { key: 'value' }];

```

이 배열은 숫자, 문자열, 불리언, 객체 등 다양한 타입을 저장할 수 있으며, 배열의 첫 번째 요소는 array[0]으로, 두 번째 요소는 array[1]과 같이 접근할 수 있습니다.

자바스크립트 배열의 중요한 특징 중 하나는 `동적 배열`이라는 점입니다. 이는 배열의 크기를 미리 지정하지 않아도 되고, 요소를 추가할 때마다 배열의 크기가 자동으로 조정됩니다.

```
const arr = [1, 2, 3];
arr.push(4); // 배열의 끝에 요소 추가
console.log(arr); // [1, 2, 3, 4]

```

또한, 배열의 특정 인덱스에 값을 할당하면, 배열이 자동으로 확장됩니다.

```
arr[5] = 6;
console.log(arr); // [1, 2, 3, undefined, undefined, 6]
console.log(arr.length); // 6

```

이처럼 자바스크립트 배열은 동적으로 크기가 조정되며, 요소를 추가하거나 특정 인덱스에 값을 할당하면, 배열은 자동으로 확장됩니다.

자바스크립트 배열의 length 속성은 배열의 크기를 나타내며, 배열에 요소가 추가되거나 제거될 때 동적으로 변경됩니다.

또한, 배열은 자바스크립트의 객체와 유사한 방식으로 관리되며, 해시 테이블과 같은 자료구조로 구현되어 있습니다. 이 덕분에 배열 요소들은 메모리 상에서 연속적이지 않아도 되며, 배열 크기를 미리 지정하지 않고 유연하게 사용할 수 있습니다.

정리하자면, 자바스크립트 배열은 다양한 데이터 타입을 담을 수 있는 유연한 `리스트형 객체`로, 동적 배열이라는 특징을 가지며, 요소를 추가하거나 제거할 때마다 배열 크기가 자동으로 조정됩니다. 또한, 여러 reduce나 map 등 다양한 내장 메서드를 통해 배열을 쉽게 조작할 수 있는 강력한 기능을 제공합니다.

</details>
<br/>

<details>
<summary>❗️ 자바스크립트 함수에 대해서 설명해주세요. </summary>
<br/>
자바스크립트 함수는 `일급 객체`로 취급되며, 여러 독특한 특징을 가지고 있습니다. 일급 객체로서의 특징은 자바스크립트 함수가 변수에 할당되거나, 다른 함수의 인자로 전달되거나, 함수에서 반환될 수 있다는 점입니다.

이를 통해 자바스크립트는 매우 유연하고, 고차 함수를 포함한 다양한 패턴을 구현할 수 있습니다.

자바스크립트 함수의 주요 특징은 여러가지가 있는데요.

**첫번째로 `일급 객체`를 말씀 드릴 수 있습니다.**

자바스크립트에서 함수는 값처럼 취급될 수 있으며, 변수에 할당하거나, 다른 함수의 인자로 전달하거나, 함수의 반환값으로 사용할 수 있습니다.

```
const sayHello = function() { return 'Hello'; };
console.log(sayHello()); // 'Hello'

const executeFunction = function(fn) {
  return fn();
};
console.log(executeFunction(sayHello)); // 'Hello'

```

**두번째로는 `익명 함수`와 `함수 표현식`입니다.**

자바스크립트에서는 이름 없는 함수를 정의할 수 있습니다. 익명 함수는 함수 표현식에서 주로 사용되며, 필요에 따라 함수에 이름을 지정하지 않아도 됩니다.

```
const add = function(a, b) {
  return a + b;
};
console.log(add(2, 3)); // 5

```

**세번째로는 `호이스팅`입니다.** 함수 선언은 코드가 실행되기 전에 호이스팅되어, 함수 선언 이전에 호출할 수 있습니다. 반면, 함수 표현식은 변수에 할당된 후에야 사용할 수 있습니다.

```
console.log(declaredFunction()); // 'Declared Function'
function declaredFunction() {
  return 'Declared Function';
}

// 함수 표현식은 할당 후에만 사용할 수 있음
const expressedFunction = function() {
  return 'Expressed Function';
};
console.log(expressedFunction()); // 'Expressed Function'

```

**네번째는 `클로저`입니다.**

자바스크립트 함수는 클로저를 지원합니다. 클로저는 함수가 **자신이 선언된 환경(스코프)** 을 기억하고, 그 외부 스코프에 접근할 수 있는 기능입니다. 이를 통해 함수는 자신이 선언된 스코프 내의 변수를 참조하고 유지할 수 있습니다.

```
function outer() {
  const outerVar = 'I am outer!';

  return function inner() {
    return outerVar; // 외부 변수에 접근 가능
  };
}
const innerFunction = outer();
console.log(innerFunction()); // 'I am outer!'

```

**다음으로는 `고차 함수`입니다.** 자바스크립트에서는 함수가 일급 객체이기 때문에, 고차 함수, 즉 다른 함수를 인자로 받거나 반환하는 함수를 정의할 수 있습니다. 이는 함수형 프로그래밍 패턴을 가능하게 합니다.

```
function multiplyBy(factor) {
  return function(num) {
    return num * factor;
  };
}
const double = multiplyBy(2);
console.log(double(5)); // 10

```

**마지막으로 화살표 함수입니다.**

화살표 함수는 더 간결한 문법을 제공하고, 특히 this 바인딩에서 기존 함수와 다른 동작을 합니다. 화살표 함수는 선언된 위치의 this 값을 유지하므로, 일반 함수와 달리 별도로 this를 바인딩할 필요가 없습니다.

```
const obj = {
  value: 42,
  method: function() {
    setTimeout(() => {
      console.log(this.value); // 42 (Arrow 함수는 obj의 this를 유지)
    }, 1000);
  }
};
obj.method();

```

요약하자면, 자바스크립트 함수는 일급 객체로써 다루어지며, 클로저, 고차 함수, 화살표 함수 등 강력한 기능들을 제공합니다.

</details>
<br/>

<details>
<summary>✅ script 태그에서 async와 defer의 차이점에 대해서 설명해주세요. </summary>
<br/>
먼저, 두 속성 모두 스크립트를 비동기적으로 로드한다는 공통점이 있습니다. 하지만 실행 시점에서 중요한 차이가 있습니다.

**async** 속성의 경우

1. 스크립트를 비동기적으로 다운로드합니다.
2. 다운로드가 완료되면 즉시 실행됩니다.
3. HTML 파싱과 병렬로 진행되지만, 스크립트 실행 시 HTML 파싱이 잠시 중단됩니다.
4. 여러 async 스크립트가 있을 경우, 다운로드가 완료되는 순서대로 실행됩니다.

이러한 특징들이 존재합니다.

**defer** 속성의 경우에는

1. 스크립트를 비동기적으로 다운로드합니다.
2. **HTML 문서 파싱이 완전히 끝난 후에 실행**됩니다.
3. **DOMContentLoaded 이벤트 발생 직전에 실행**됩니다.
4. 여러 defer 스크립트가 있을 경우, **HTML에 작성된 순서대로 실행**됩니다.

따라서, **실행 순서가 중요한 스크립트나 메인 어플리케이션의 로직을 담고 있는 스크립트의 경우 defer를 사용하고**, 독립적으로 실행되는 스크립트의 경우 (예들 들면 Google Analytics 같은 분석 도구) async를 사용하는 것이 적절합니다.

이러한 차이를 이해하고 적절히 활용하면 웹 페이지의 로딩 성능을 최적화하는 데 큰 도움이 됩니다.

</details>
<br/>

<details>
<summary>⚡️ 이벤트 전파(event propagation)에 대해서 설명해주세요.
 </summary>
<br/>
이벤트 전파는 DOM에서 이벤트가 발생했을 때, 그 이벤트가 어떤 방식으로 전파되는지를 설명하는 개념입니다.

이벤트 전파는 크게 세 단계로 나뉘는데, 캡처링(Capturing), 타겟(Target), 그리고 **버블링(Bubbling)**입니다.

첫번째로 캡처링 단계에 대해서 설명 드리겠습니다. 이벤트가 DOM 트리의 최상위 요소(document 또는 window)에서 시작하여, 이벤트가 발생한 요소(타깃 요소)로 향해 내려가는 단계입니다. 이 과정에서 상위 요소들에 이벤트 리스너가 있으면 그 순서대로 실행될 수 있습니다.

두번째로는 타겟 단계입니다. 이벤트가 실제로 발생한 타겟 요소에 도달하는 단계입니다. 타겟 요소에 등록된 이벤트 리스너가 이 시점에 실행됩니다.

마지막으로 버블링 단계입니다. 타겟 요소에서 이벤트가 발생한 후, 다시 DOM 트리의 상위 요소들로 이벤트가 전파되어 올라가는 단계입니다. 이 과정에서 상위 요소들에 등록된 이벤트 리스너들이 실행될 수 있습니다.

기본적으로 대부분의 이벤트는 버블링을 통해 전파되지만, addEventListener의 세 번째 인자로 { capture: true }를 전달하면, 캡처링 단계에서도 이벤트를 처리할 수 있습니다.

이벤트 전파는 웹 페이지에서 요소 간의 상호작용을 제어하는 데 중요한 역할을 하며, `event.stopPropagation()` 메서드를 사용하여 특정 단계에서 이벤트의 전파를 중단할 수 있습니다.

정리해서 말씀 드려보자면 이벤트 전파는 DOM 구조에서 이벤트가 어떻게 상위와 하위 요소 간에 전달되는지를 정의하는 메커니즘이며, 이를 통해 복잡한 사용자 상호작용을 효율적으로 관리할 수 있습니다.

</details>
<br/>

<details>
<summary>🌪️ 인터프리터 언어인 자바스크립트에서 어떻게 호이스팅이 가능한지에 대해서 설명해주세요.
 </summary>
<br/>
자바스크립트에서 호이스팅이 가능한 이유는 인터프리터 언어라고 해도 자바스크립트 엔진이 코드를 실행하기 전에 두 단계의 실행 과정을 거치기 때문입니다.

이 두 단계는 **컴파일 단계**와 **실행 단계**로 나눌 수 있으며, 이 과정에서 호이스팅이 발생하게 됩니다. 구체적으로 말씀드려보겠습니다.

첫번째로 **컴파일 단계**입니다.

자바스크립트 엔진은 스크립트를 실행하기 전에 먼저 **컴파일 단계**를 거칩니다. 이 과정에서 함수 및 변수 선언을 한 부분이 메모리에 할당됩니다. 이때 변수와 함수 선언을 미리 메모리에 올려두기 때문에 실제 코드에서 선언된 위치보다 앞에서 접근이 가능해지는 것입니다.

`let`, `const`가 아닌 `var`를 통해 선언되면, 컴파일 단계에서 변수가 메모리에 올라가며, 이때 값은 undefined로 초기화됩니다. 이후 실행 단계에서 코드가 진행되면서 실제 할당된 값이 대입됩니다.

```
console.log(myVar); // undefined
var myVar = 5;
console.log(myVar); // 5

```

위의 예시에서 myVar 변수 선언이 코드의 최상단으로 "호이스팅"되어 컴파일 단계에서 메모리에 먼저 올라가고, 초기값은 undefined로 설정됩니다.

따라서 console.log(myVar)의 첫 번째 출력에서 undefined가 나오는 것입니다.

두번째로 실행 단계입니다.

실행 단계란 실제 코드가 실행되는 과정으로, 컴파일 단계에서 메모리에 할당된 변수와 함수가 실행됩니다. 여기서 변수가 할당된 값을 가지게 되고, 함수가 호출되면 그 안의 코드가 수행됩니다.

정리해서 말씀 드려보겠습니다. 인터프리터 언어임에도 자바스크립트가 호이스팅이 가능한 이유는 자바스크립트 엔진이 코드를 단순히 한 줄씩 바로 해석하고 실행하지 않고, 먼저 컴파일 단계에서 코드를 파악하고 필요한 메모리를 확보하는 과정을 거치기 때문입니다.

이를 통해 코드 내에서 선언 위치와 상관없이 변수를 사용할 수 있는 유연성을 제공합니다.

</details>
<br/>

<details>
<summary>🤪 자바스크립트는 싱글 스레드 언어인데, 어떻게 동시에 여러 작업들을 수행하나요?
 </summary>
<br/>
자바스크립트는 **싱글 스레드 언어**입니다. 즉, 한 번에 하나의 작업만을 처리할 수 있는 **단일 콜 스택**을 가집니다. 하지만 브라우저나 Node.js 환경이 제공하는 비동기 처리 메커니즘 덕분에 여러 작업을 동시에 수행할 수 있습니다.

자바스크립트는 브라우저의 **Web API**나 Node의 **libuv**, **이벤트 루프**, **태스크 큐**를 이용하여 비동기 작업을 동시에 처리합니다.

비동기 작업이 발생하면, 해당 작업(타이머, 네트워크 요청 등)은 브라우저의 **Web API**에 위임됩니다. 예를 들어, `setTimeout`이나 `fetch`와 같은 작업이 수행되면 자바스크립트 엔진은 이 작업들을 Web API에 넘기고 다른 코드 실행을 이어갑니다. Web API에서 비동기 작업이 완료되면, 그 작업은 **태스크 큐**에 들어가 대기합니다.

이후 **이벤트 루프**가 콜 스택이 비어있는지 확인한 뒤 **태스크 큐**에서 대기 중인 작업을 콜 스택으로 가져와 실행합니다. 이러한 구조 덕분에 자바스크립트는 싱글 스레드임에도 비동기적으로 작업을 처리하여 다양한 작업을 효율적으로 관리할 수 있습니다. 이 메커니즘 덕분에 UI 인터랙션이 끊기지 않으며, 대기 시간이 필요한 작업도 동시에 실행되는 것과 같이 동작하게 됩니다.

## **앞서 말씀하신 태스크 큐의 종류에는 어떤 게 있나요?**

자바스크립트의 태스크 큐는 크게 **매크로태스크 큐**와 **마이크로태스크 큐**로 나뉩니다. 이들 큐는 비동기 작업의 우선순위를 관리하고, 이벤트 루프가 적절한 시점에 콜백을 실행하기 위해 사용됩니다.

첫째, **매크로태스크 큐**는 일반적인 비동기 작업의 콜백이 저장되는 큐입니다.

`setTimeout`, `setInterval`, I/O 작업, 이벤트 핸들러 등은 작업 완료 후 매크로태스크 큐에 콜백을 대기시킵니다. 매크로태스크 큐는 이벤트 루프의 한 번의 반복마다 하나의 태스크만 처리되므로, UI 업데이트나 다른 작업과 균형 있게 진행됩니다.

둘째, **마이크로태스크 큐**는 더 높은 우선순위가 필요한 비동기 작업들이 대기하는 큐입니다.

`Promise.then`, `MutationObserver` 등의 비동기 콜백이 여기에 저장됩니다. 이벤트 루프는 매크로태스크를 실행하기 전에 항상 마이크로태스크 큐를 먼저 확인하고, 모든 마이크로태스크를 처리한 후 매크로태스크로 넘어갑니다. 이 방식으로 마이크로태스크 큐의 작업은 높은 우선순위로 처리됩니다.

</details>
<br/>

<details>
<summary>🎛️ 자바스크립트 클래스의 접근제어자에 대해 설명해주세요.
 </summary>
<br/>
자바스크립트에서 클래스의 **Public, Private, Protected** 접근제어자는 클래스 멤버의 접근 범위를 제어하는 데 사용됩니다.

**Public**은 별도 키워드를 붙이지 않았을 때 기본 적용되는 접근제어자로, 클래스 외부에서도 자유롭게 접근 가능합니다. 예를 들어, `this.name = "John”;`처럼 선언된 멤버는 Public으로 간주됩니다. 이는 클래스 외부에서 객체를 통해 직접 접근할 수 있습니다.

**Private**은 멤버 앞에 `#` 키워드를 붙여 적용하는 접근제어자로, 클래스 내부에서만 접근 가능하게 됩니다. 예를 들어, `this.#secret = "hidden”;`처럼 선언된 멤버는 Private으로 간주됩니다 . Private 멤버는 객체를 통한 외부 접근이 불가능하며, 상속받은 클래스에서도 사용할 수 없게 됩니다.

**Protected**는 자바스크립트 언어 차원에서 지원하지 않지만, 관습적으로 `_`를 접두어로 사용해 개발자 간 약속으로 처리합니다. 예를 들어, `this._secret = ‘hidden’;`과 같은 방식으로 선언하여 Protected임을 나타냅니다. 이는 상속받은 클래스에서 접근하는 것은 허용하지만 클래스 외부에서는 사용하지 말라는 의미를 나타냅니다. 즉, 클래스 외부에서 객체를 통한 접근은 하지 않을 것을 개발자들 간에 약속하는 것입니다. 이는 언어 차원의 강제성은 없습니다.

접근제어자를 활용하면 코드의 캡슐화를 통해 데이터 보호와 유지보수를 향상시킬 수 있습니다.

## **타입스크립트에서는 접근제어자와 관련해 어떤 차이점이 존재하나요? 🤔**

첫째, **타입스크립트에서는 자바스크립트에서 지원하지 않는 접근제어자 키워드들을 제공**하기 때문에 더욱 명시적인 방식으로 접근제어자를 선언할 수 있습니다.

`public` 키워드를 이용하여 **Public 멤버**임을 선언할 수 있습니다. 아무 키워드를 붙이지 않을 때와 동작은 동일하지만 그 의미를 명시적으로 나타낼 수 있게 해줍니다.

`#` 키워드 대신 `private` 키워드를 이용하여 **Private 멤버**임을 선언할 수 있습니다.

`_` 키워드 컨벤션 대신 `protected` 키워드를 이용하여 **Protected 멤버**임을 선언할 수 있습니다.

**예시**

```jsx
class Foo {
  public a: string; // 상속 클래스 접근 O / 외부 접근 O
  private b: number; // 상속 클래스 접근 X / 외부 접근 X
  protected c: boolean; // 상속 클래스 접근 O / 외부 접근 X

  constructor(a: string, b: number, c: boolean) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
}

```

둘째, **타입스크립트에서는 파라미터 프로퍼티(Parameter Properties) 기능을 제공**합니다. 이는 생성자 매개변수에 접근제어자를 붙이면 해당 변수를 멤버로 자동 선언하고 초기화되는 기능입니다. 이로 인해 코드를 간결하게 작성할 수 있습니다.

**예시**

```
class Foo {
  constructor(public a: string, private b: number, protected c: boolean) {
    // 이 부분을 채우지 않아도 자동으로 멤버 선언 및 초기화
  }
}
```

</details>
<br/>

<details>
<summary>🎃 event.target과 event.currentTarget의 차이점은 무엇인가요?
 </summary>
<br/>
✅ event.target
실제로 이벤트가 발생한 요소를 가리킵니다.

사용자가 클릭하거나 입력 등 이벤트를 직접 발생시킨 요소예요.

✅ event.currentTarget
이벤트 핸들러가 바인딩된 요소를 가리킵니다.

</details>
<br/>

<details>
<summary>🐣 자바스크립트에서 생성자 함수가 무엇인지, class 문법은 왜 도입되었는지 설명해주세요.
 </summary>
<br/>
생성자 함수가 무엇인가요?
자바스크립트에서 생성자 함수는 객체를 생성하는 하나의 방법입니다. 일반적으로 function 키워드를 사용하여 정의하며, new 키워드와 함께 호출할 경우 새로운 객체가 만들어집니다. 생성자 함수 내부에서 this 키워드는 새롭게 생성된 객체를 가리키며, 여기에 속성을 추가하면 해당 객체에 저장됩니다.

예를 들어, 다음과 같은 방식으로 생성자 함수를 사용할 수 있습니다.

function Person(name, age) {
this.name = name;
this.age = age;
}

Person.prototype.greet = function() {
console.log(`안녕하세요, 저는 ${this.name}입니다.`);
};

const person1 = new Person('Alice', 25);
class 문법은 왜 도입되었나요? 🤔
생성자 함수는 유지보수성이 떨어진다는 문제가 있습니다. 우선, 명확한 클래스 개념이 없기 때문에 상속을 구현할 때 프로토타입 체인을 이용해야 하는데, 이는 가독성이 좋지 않습니다. 다른 객체지향 언어와 형태가 많이 다르기 때문에 이해하기 비교적 어렵기도 합니다. 또한 new 키워드 없이 일반 함수처럼 호출될 수도 있어 혼동을 유발합니다.

이러한 단점을 극복하기 위해 class 문법이 등장했습니다. class를 사용하면 객체를 생성하는 코드를 더욱 직관적으로 작성할 수 있습니다. 예시와 함께 설명드리겠습니다.

class Person {
constructor(name, age) {
this.name = name;
this.age = age;
}

greet() {
console.log(`안녕하세요, 저는 ${this.name}입니다.`);
}
}

const person2 = new Person('Bob', 30);
이처럼 class를 사용하면 생성자와 메서드를 명확하게 정의할 수 있습니다. 또한 다른 객체지향 언어의 문법과 유사한 형태여서 이해하기 쉽습니다. extends, super를 이용하여 상속을 간결하게 구현할 수 있고, static, getter/setter 등 객체지향 관련 키워드를 지원하기도 합니다. 또한, 생성자 함수와 달리 일반 함수처럼 호출할 수 없도록 하는 제약이 추가됩니다.

</details>
<br/>

<details>
<summary>🛜 프로토타입 상속의 동작 방식에 대해 설명해주세요.</summary>
<br/>
프로토타입은 자바스크립트에서 객체 간의 상속을 구현하는 메커니즘입니다. 자바스크립트의 모든 객체는 기본적으로 `[[Prototype]]`이라는 숨김 프로퍼티를 가지고 있으며, 이 프로퍼티는 다른 객체를 참조하거나 `null` 값을 가집니다. 프로토타입 연결은 `Object.create()`나 함수 생성자의 `prototype` 프로퍼티를 통해 이루어집니다.

**프로토타입 상속이 동작하는 방식은 프로토타입 체인을 기반**으로 합니다. 객체에서 어떤 프로퍼티를 접근하려고 할 때, 자바스크립트 엔진은 해당 객체에서 프로퍼티를 찾습니다. 그리고 만약 찾을 수 없다면, 객체의 `[[Prototype]]`이 가리키는 프로토타입 객체에서 프로퍼티를 탐색합니다. 만약 프로토타입 객체에서도 해당 프로퍼티를 찾지 못하면, 그 다음에는 프로토타입의 프로토타입을 탐색합니다. 탐색 과정을 계속 반복하면서 결국 원하는 프로퍼티를 찾거나, 프로토타입이 `null`이 되는 단계에 도달할 때까지 프로토타입 체인을 타고 올라가는 방식으로 탐색합니다. 이런 식으로 프로토타입이 꼬리에 꼬리를 물고 연결된 형태를 두고 **프로토타입 체인**이라고 부르는 것입니다.

### **예시 코드**

```
// 1) Object.create()를 이용한 방식
const dog = {
  greet() {
    console.log('Hello from dog!');
  }
};

const maru = Object.create(dog); // maru의 프로토타입이 dog로 설정됨
maru.greet(); // "Hello from dog!" 출력

```

```
// 2) prototype 프로퍼티를 이용한 방식
function Dog() {}
Dog.prototype.greet = function () {
  console.log('Hello from Dog!');
};

const maru = new Dog(); // maru의 프로토타입이 dog로 설정됨
maru.greet(); // "Hello from Dog!" 출력

```

객체 `maru`가 `dog`를 프로토타입으로 갖는다고 가정해봅시다. 만약 `maru.greet()`을 호출했을 시 `maru`에 `greet()`이 없으면 프로토타입인 `dog`에 `greet()`이 존재하는지 탐색합니다. 이때 `dog`에 `greet()`이 존재하면 탐색을 멈추고 해당 메서드를 호출합니다. 만약 `dog`에도 존재하지 않는다면 프로토타입 체인의 끝에 도달할 때까지 상위 프로토타입을 계속 탐색해 나갑니다.

</details>
<br/>

<details>
<summary>😁 상황에 따라 this 바인딩이 어떻게 이뤄지는지 설명해주세요.</summary>
<br/>
자바스크립트에서 **`this`는 함수가 호출되는 방식에 따라 값이 달라집니다**. 다양한 상황에서 `this`가 어떻게 바인딩되는지 크게 6가지 상황으로 나누어 설명드리겠습니다.

### **1. 전역 호출**

전역에서 함수가 호출되면, **`this`는 전역 객체를 참조합니다**. 브라우저 환경에서는 `window` 객체를, Node.js 환경에서는 `global` 객체를 가리킵니다.

```
function globalFunc() {
  console.log(this);
}
globalFunc(); // 브라우저: window, Node.js: global

```

### **2. 메서드 호출**

객체의 메서드로 호출된 함수에서는 **`this`가 해당 객체를 참조합니다**.

```
const obj = {
  name: "Alice",
  greet: function () {
    console.log(this.name);
  },
};
obj.greet(); // "Alice"

```

### **3. 생성자 함수와 클래스**

생성자 함수나 클래스에서 `this`는 **새로 생성되는 객체, 즉 인스턴스를 참조합니다**.

```
function Person(name) {
  this.name = name;
}
const person = new Person("Alice");
console.log(person.name); // "Alice"

```

### **4. 명시적 바인딩**

`call()`, `apply()`, `bind()` 메서드를 사용하면 **`this`를 명시적으로 설정할 수 있습니다**.

```
function greet() {
  console.log(this.name);
}
const user = { name: "Alice" };
greet.call(user); // "Alice"

```

### **5. 화살표 함수**

화살표 함수는 **상위 스코프의 `this`를 상속받습니다**. 자체적인 `this`를 가지지 않으므로, 사용 위치에 따라 `this`가 결정됩니다.

```
const obj = {
  name: "Alice",
  greet: () => console.log(this.name),
};
obj.greet(); // undefined (전역 `this`)

```

### **6. DOM 이벤트 핸들러**

DOM 요소의 이벤트 핸들러에서 **`this`는 기본적으로 이벤트를 발생시킨 요소를 참조합니다**. 하지만 화살표 함수를 사용하면 상위 스코프의 `this`를 참조합니다.

```
button.addEventListener("click", function () {
  console.log(this); // 클릭된 button 요소
});

```

지금까지 설명드린 것과 같이 **`this`는 함수 호출 방식에 따라 값이 달라집니다**. 따라서 상황에 따른 동작을 이해하고 적절한 방식을 사용해야 합니다. 특히, 화살표 함수와 명시적 바인딩은 `this`를 제어하는 데 유용합니다.

</details>
<br/>

<details>
<summary>다음 JS 코드의 실행 결과를 설명해주세요.</summary>
<br/>

```
function change(a, b, c) {
    a = 'a changed'
    b = { b: 'changed' };
    c.c = 'changed';
}

let a = 'a unchanged';
let b = { b: 'unchanged' };
let c = { c: 'unchanged' };

change(a, b, c);

console.log(a, b, c); // ?
```

자바스크립트는 **Call by Value 방식**으로 매개변수를 전달합니다. 이는 함수 매개변수에 **값의 복사본**이 전달된다는 의미입니다. 이로 인해 다음과 같은 결과가 나타납니다.

### **1. a (문자열)**

`a`는 문자열입니다. 문자열 값의 복사본이 파라미터에 전달되므로, 함수 내에서 값이 변경되어도 호출한 곳의 변수에는 영향을 미치지 않습니다.

따라서 호출한 곳의 `a`는 여전히 `'a unchanged'`로 유지됩니다.

### **2. b (객체)**

`b`는 객체입니다. 원본 객체의 참조 값(주소)의 복사본이 파라미터에 전달됩니다. `b = { b: 'changed' }`와 같이 객체를 새롭게 할당하면, 해당 복사본이 가리키는 참조 값이 새로운 객체의 참조 값으로 변경됩니다. 이로 인해 함수 내의 복사본 `b`는 `b = { b: 'changed' }`의 참조 값을 가리키게 되지만, 함수 외부의 `b`는 여전히 `{ b: 'unchanged' }`로 유지됩니다.

### **3. c (객체)**

`c`는 객체입니다. 원본 객체의 참조 값의 복사본이 파라미터에 전달됩니다. 함수 내부와 외부의 변수가 모두 동일한 참조 값을 가리키고 있으므로, 함수 내부에서 객체의 속성을 변경하면 호출한 곳의 객체에도 영향을 미칩니다.

`c.c = 'changed'`는 c 객체의 속성을 변경한 것이므로, 호출한 곳의 c 객체는 `{ c: 'changed' }`로 변경됩니다.

</details>
<br/>

<details>
<summary>🔗 커링(currying)이란 무엇인가요? </summary>
<br/>
커링이란, 여러 개의 인자를 받는 함수를 단일 인자를 받는 함수들의 함수열로 바꾸는 기법입니다. 다시 말해, 여러 개의 인자를 한번에 받지 않고, 하나씩 여러 차례 받는 형태로 변환합니다.

```
function add(a) {
  return function(b) {
    return a + b;
  };
}

add(2)(3); // 5
```

const addTwo = add(2)
addTwo(3); // 5
예를 들어, 두 수를 더하는 함수를 일반적으로 작성하면 add(2, 3)처럼 두 개의 인자를 동시에 전달해야 합니다. 하지만 커링을 적용하면 add(2)(3)처럼 하나씩 나눠서 인자를 전달할 수 있습니다. 혹은 const addTwo = add(2)와 같이 함수를 선언해둔 후, 필요할 때 재사용할 수도 있습니다.

## 커링의 장점은 무엇인가요?

먼저, 커링을 적용하면 코드의 재사용성이 증가합니다. 예시를 들어 설명드리겠습니다.

```
// ❌ 커링 미적용
const numbers = [10, 20, 30, 40, 50]

const greaterThan30 = numbers.filter(n => n > 30)
const greaterThan20 = numbers.filter(n => n > 20)
```

위와 같은 코드에 커링을 적용하면 아래와 같이 재사용성을 개선할 수 있습니다.

```
// ✅ 커링 적용
const isGreaterThan = (min: number) => (value: number) => value > min

const numbers = [10, 20, 30, 40, 50]

const greaterThan30 = numbers.filter(isGreaterThan(30))
const greaterThan20 = numbers.filter(isGreaterThan(20))
```

또한, 커링을 적용하면 함수 합성이 쉬워집니다. 함수형 프로그래밍에서 함수 합성을 위해 compose()나 pipe()와 같은 함수를 활용하는데요. 이때 커링을 적용하면 단일 인자 함수로 변환할 수 있기 때문에 compose()나 pipe()에 끼워 넣어 활용할 수 있습니다.

```
const add = a => b => a + b;

const square = x => x * x;
const toString = x => x.toString();

const pipe = (...fns) => input =>
  fns.reduce((acc, fn) => fn(acc), input);

const process = pipe(
  add(2),
  square,
  toString
);

console.log(process(3)); // "25"
```

</details>
<br/>

<details>
<summary>🔄 이터러블 프로토콜에 대해 설명해주세요.

 </summary>
<br/>
이터러블 프로토콜은 자바스크립트에서 데이터를 순차적으로 순회하여 탐색할 수 있도록 정해놓은 프로토콜입니다. 이터러블 프로토콜이 존재하는 이유는, 다양한 자료구조를 같은 방식으로 순회할 수 있게 하여 일관된 반복 처리 방법을 제공하기 위함입니다.

예를 들어 배열, String, Set, Map 등은 서로 다른 구조를 가지고 있지만, 이터러블 프로토콜을 따르고 있기 때문에 for...of 문이나 스프레드 연산자 같은 문법으로 동일하게 순회할 수 있습니다. 이런 통일성 덕분에 개발자는 자료구조마다 다른 순회 방식을 고민하지 않아도 됩니다.

이터러블로 간주되기 위해서는 해당 객체에 Symbol.iterator라는 키를 가진 메서드가 정의되어 있어야 하며, 이 메서드는 이터레이터 객체를 반환해야 합니다. 이때 반환된 이터레이터 객체는 next()라는 메서드를 가지고 있으며, 이 메서드를 호출하면 { value, done } 형태의 결과를 반환해야 합니다. 이 과정을 통해 내부 데이터를 순서대로 꺼내는 것이 가능합니다.

정리하면, 이터러블 프로토콜의 핵심 목적은 “순회할 수 있는 객체”의 공통된 인터페이스를 정의하여, 일관된 방식으로 데이터를 탐색할 수 있게 하는 것입니다.

### 직접 이터러블 객체를 구현해보실 수 있을까요? 🤔

네, 가능합니다. 객체에 Symbol.iterator 메서드를 직접 구현하면 커스텀 이터러블을 만들 수 있습니다.

```

const customIterable = {
  data: [1, 2, 3],
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        return index < this.data.length
          ? { value: this.data[index++], done: false }
          : { done: true };
      }
    };
  }
};

for (const item of customIterable) {
  console.log(item); // 1, 2, 3 차례로 출력
}

```

</details>
<br/>

<details>
<summary>🤚 제네레이터에 대해 설명해주세요.  </summary>
<br/>
제네레이터(Generator)는 자바스크립트에서 반복 가능한 데이터를 만들거나, 실행 흐름을 중간에 멈췄다가 다시 이어서 실행할 수 있게 해주는 특수한 함수입니다. 일반 함수와 다르게 function* 키워드로 정의하며, 내부에서 yield 키워드를 사용해 값을 순차적으로 반환합니다.

제네레이터 함수는 실행하면 즉시 코드가 실행되지 않고, 대신 이터레이터 객체를 반환합니다. 이 이터레이터는 next() 메서드를 통해 하나씩 값을 꺼낼 수 있으며, yield 지점에서 멈췄다가, 다음 next() 호출 시 그 지점부터 다시 실행됩니다.

```
function* myGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = myGenerator();
console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }
```

제네레이터의 가장 큰 특징은 함수의 실행 상태를 보존하면서 여러 번 호출할 수 있다는 점입니다. 이 덕분에 데이터를 지연 평가하거나 복잡한 반복 로직, 커스텀 이터러블 등을 구현할 때 유용하게 사용됩니다.

### 제네레이터를 실제로 유용하게 활용한 예시를 들어줄 수 있나요? 🤔

예를 들어, 제네레이터를 활용하면, 배열에서 조건에 맞는 값만 순회하고 싶을 때 조건 필터링을 포함한 이터러블을 만들 수 있습니다.

```
function* validNumbers(numbers) {
  for (const num of numbers) {
    if (typeof num === "number" && !isNaN(num)) {
      yield num;
    }
  }
}

const mixed = [1, "a", 2, NaN, 3];
for (const n of validNumbers(mixed)) {
  console.log(n); // 1, 2, 3
}
```

</details>
<br/>
