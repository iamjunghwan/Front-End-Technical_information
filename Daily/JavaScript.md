<details>
<summary> 클로저에 대해서 설명해주세요</summary>
<br/>
클로저는 함수가 선언될 때의 스코프를 기억하여, 함수가 생성된 이후에도 그 스코프에 접근할 수 있는 기능을 말합니다. 비유하자면, 함수가 자신이 생성된 환경을 '기억'하는 것이라고 할 수 있습니다. 클로저는 자바스크립트의 함수가 일급 객체라는 특성과 렉시컬 스코프의 조합으로 만들어집니다.

예시와 함께 클로저의 동작을 설명드리면 좋을 것 같습니다.

**클로저 예시 코드**

```jsx
function outerFunction(outerVariable) {
  return function innerFunction(innerVariable) {
    console.log("Outer Variable: " + outerVariable);
    console.log("Inner Variable: " + innerVariable);
  };
}

const newFunction = outerFunction("outside");
newFunction("inside");
```

여기서 `innerFunction`은 `outerFunction`의 내부에 정의되어 있습니다. `innerFunction`은 자신이 생성된 스코프, 즉 `outerFunction`의 스코프를 기억하고, `outerFunction`의 호출이 완료된 이후에도 그 스코프에 접근할 수 있습니다. 그리고 이에 따라 `innerFunction`은 `outerVariable`에도 접근할 수 있습니다. 이것이 클로저가 동작하는 방식입니다.

## **클로저는 언제 활용하나요?**

클로저는 변수와 함수의 접근 범위를 제어하고 특정 데이터와 상태를 유지하기 위해 자주 활용됩니다. 크게 세 가지 대표적인 사용 사례로 나누어 설명드릴 수 있습니다.

첫째, 데이터 은닉에 활용됩니다. 클로저는 외부에서 접근할 수 없는 비공개 변수와 함수를 만들 수 있습니다. 이를 통해 데이터를 은닉하여 외부 접근을 막고, 데이터 무결성을 유지할 수 있습니다. 예를 들어, 특정 함수 내부에서만 접근 가능한 변수를 생성하고, 이를 조작할 수 있는 함수만 외부로 노출하여 안전하게 데이터를 관리할 수 있습니다.

둘째, 비동기 작업에 활용됩니다. 클로저는 비동기 작업에서 이전의 실행 컨텍스트를 유지해야 할 때 유용합니다. 콜백 함수가 비동기적으로 실행될 때 클로저를 사용하면 함수 실행 시점의 변수를 참조할 수 있습니다.

```
function createLogger(name) {
  return function() {
    console.log(`Logger: ${name}`);
  };
}

const logger = createLogger('MyApp');
setTimeout(logger, 1000); // 1초 후에 'Logger: MyApp' 출력

```

위의 예시에서 클로저가 `name` 변수(`'MyApp'`)를 저장하여 1초 후에도 해당 값이 유지되어 출력됩니다.

셋째, 모듈 패턴을 구현하는 데 활용됩니다. 모듈 패턴은 특정 기능을 캡슐화하고, 외부에 공개하고자 하는 부분만 선택적으로 노출하여 코드의 응집력을 높이고, 유지보수성을 향상시키는 패턴입니다. 클로저를 활용하면 필요한 함수와 데이터만 외부로 노출함으로써 모듈 패턴을 쉽게 구현할 수 있습니다.

</details>
<br/>

<details>
<summary>실행 컨텍스트에 대해서 설명해주세요. </summary>
<br/>
**실행 컨텍스트**는 자바스크립트에서 코드가 실행되는 환경을 의미합니다. 자바스크립트 엔진이 코드를 실행할 때, 그 코드가 실행될 때의 환경을 정의하고 관리하기 위해 존재하는 것이 실행 컨텍스트입니다.

실행 컨텍스트는 크게 **전역 실행 컨텍스트**와 **함수 실행 컨텍스트**로 나눌 수 있습니다.

**전역 실행 컨텍스트**는 자바스크립트가 처음 실행될 때 생성되는 컨텍스트입니다. 이 전역 컨텍스트는 프로그램이 종료될 때까지 유지되며, 전역에 선언된 변수나 함수가 모두 포함됩니다. 전역 컨텍스트에서 선언된 변수와 함수는 프로그램 내 어디서든 접근이 가능합니다.

기본적으로 자바스크립트는 싱글 스레드이기때문에, 전역 실행 컨텍스트는 1개만 존재합니다.

**함수 실행 컨텍스트**는 함수가 호출될 때마다 생성 되는 컨텍스트를 의미합니다. 각 함수는 자신만의 실행 컨텍스트를 가지며, 이 컨텍스트 내에서 선언된 변수와 함수는 해당 함수 내에서만 유효합니다. 함수가 종료되면 그 실행 컨텍스트도 함께 사라집니다.

## **실행 컨텍스트는 어떤 구성 요소로 이루어져 있나요?**

요약하면, 실행 컨텍스트는 `변수 객체`, `스코프 체인`, `this` 라는 구성요소로 이루어져 있습니다.

첫째, **변수객체**란 실행 컨텍스트 내에서 사용되는 변수와 함수 선언을 저장하는 공간입니다. 전역 컨텍스트에서는 전역 객체가 변수 객체의 역할을 하고, 함수 컨텍스트에서는 **활성화 객체**가 변수와 매개변수를 관리합니다.

두번째로는 **스코프 체인**입니다. 현재 실행 중인 컨텍스트와 외부 렉시컬 환경의 연결을 유지합니다. 변수를 참조할 때 현재 컨텍스트에서 찾지 못하면 외부 환경으로 범위를 넓혀가며 변수를 찾습니다.

마지막으로 **this**입니다. **this**는 실행 컨텍스트에 따라 참조하는 객체가 달라집니다. 전역 컨텍스트에서는 this가 전역 객체를 가리키며, 함수 컨텍스트에서는 함수 호출 방법에 따라 달라집니다.

실행 컨텍스트는 이러한 구성 요소를 바탕으로 자바스크립트 코드가 실행되는 동안의 환경을 관리하고, 코드 실행 시 변수의 유효 범위나 함수 호출의 맥락을 결정 짓습니다.

</details>
<br/>

<details>
<summary>이벤트 루프에 대해서 설명해주세요.</summary>
<br/>
자바스크립트의 **이벤트 루프**는 자바스크립트가 싱글 스레드 기반 언어임에도 불구하고 **비동기 작업을 처리할 수 있게 해주는** 중요한 메커니즘입니다.

자바스크립트는 기본적으로 한 번에 하나의 작업만 처리할 수 있습니다. 하지만 이벤트 루프가 **콜 스택**과 **태스크 큐**를 관리하면서 비동기 작업이 완료되면 그 결과를 처리할 수 있게 도와줍니다. 여기서, **콜 스택**은 현재 실행 중인 코드들이 쌓이는 곳이고, **태스크 큐**는 비동기 작업이 완료되면 그 결과를 대기시키는 곳입니다.

이벤트 루프의 동작을 설명하기 위해 간단한 예로 `setTimeout(callback, 0)`을 들어 보겠습니다. 자바스크립트 코드에서 `setTimeout(callback, 0)`을 호출하면, 이 콜백 함수는 바로 실행되는 것이 아니라 웹 API에 의해 타이머가 설정되고, 그 타이머가 0밀리초 후에 만료되면 콜백 함수가 태스크 큐에 추가됩니다. 그 후 콜 스택이 비어 있는 시점에 이벤트 루프가 태스크 큐에서 대기 중인 `callback`을 꺼내서 실행합니다.

따라서 `setTimeout(callback, 0)`을 호출해도 현재 실행 중인 모든 동기 작업들이 완료된 후에야 그 콜백이 실행됩니다. 이 때문에 `setTimeout(callback, 0)`을 사용하면 코드의 실행을 다음 이벤트 루프 사이클로 미뤄집니다.

이와 같이 **이벤트 루프**는 자바스크립트의 **비동기 작업**을 처리하는 데 있어서 매우 중요한 역할을 합니다. 이벤트 루프 덕분에 자바스크립트는 UI 업데이트나 사용자 입력 처리를 수행하면서도, 비동기 작업을 블로킹 없이 병렬적으로 처리할 수 있습니다.

## **앞서 말씀하신 태스크 큐의 종류에는 무엇이 있나요?**

태스크 큐는 **매크로태스크 큐**와 **마이크로태스크 큐**로 나뉩니다.

**매크로태스크 큐**는 `setTimeout`, `setInterval` 같은 일반적인 비동기 작업들이 대기하는 큐입니다. 매크로태스크 큐의 작업은 이벤트 루프가 콜 스택과 마이크로태스크 큐의 작업을 모두 처리한 후, 하나씩만 처리합니다.

**마이크로태스크 큐**는 `Promise.then()`과 같이 중요도가 높은 작업들이 대기하는 큐입니다. 마이크로태스크 큐는 매크로태스크 큐보다 우선순위가 높습니다. 이벤트 루프는 콜 스택이 비어있는 시점에 매크로태스크를 실행하기 이전에 마이크로태스크 큐에 있는 모든 작업들을 먼저 처리합니다.

이처럼 태스크 큐는 크게 `마이크로태스크 큐`와 `매크로태스크 큐`로 이뤄져 있으며, `마이크로태스크 큐` 작업은 `매크로태스크 큐` 작업보다 우선적으로 실행됩니다.

</details>
<br/>

<details>
<summary>  자바스크립트 호이스팅에 대해서 설명해주세요. </summary>
<br/>
`호이스팅(Hoisting)`은 자바스크립트가 코드를 실행하기 전에 변수와 함수 선언을 코드의 최상단으로 끌어올리는 것처럼 동작하는 특징입니다. 이를 통해 코드의 선언된 위치와 관계없이 변수를 사용할 수 있는 것처럼 보일 수 있습니다.

하지만 호이스팅은 선언의 호이스팅일 뿐, 변수의 값 할당까지 끌어올려지지는 않습니다. 예를 들어 var로 선언된 변수는 선언 자체는 호이스팅되지만, 초기화되기 전까지는 undefined로 평가됩니다. 예시로는 다음과 같습니다.

```
console.log(myVar); // undefined

var myVar = 10;
console.log(myVar); // 10

```

함수 선언은 전체가 호이스팅되기 때문에, 함수 호출을 선언 이전에 해도 문제가 없습니다.

```
console.log(myFunction()); // 'Hello World' 출력

function myFunction() {
  return 'Hello World';
}

```

그러나 ES6에서 도입된 let과 const는 호이스팅이 되긴 하지만, 선언하기 전에 접근하려고 하면 ReferenceError가 발생합니다.

이는 `Temporal Dead Zone(TDZ)`이라는 개념 때문입니다. TDZ는 변수가 선언되었지만 초기화되기 전까지의 구간을 말합니다. let과 const로 선언된 변수는 TDZ가 존재하며, 이 구간에서는 변수에 접근할 수 없습니다.

```
console.log(myLet); // ReferenceError 발생

let myLet = 10;

```

이 경우, 변수 선언은 호이스팅되었지만 초기화는 변수 선언이 실제로 실행될 때까지 이루어지지 않습니다. TDZ는 코드에서 변수가 선언된 시점부터 초기화될 때까지의 구간에서 변수를 사용하지 못하게 막아주는 역할을 합니다.

따라서 호이스팅은 변수와 함수 선언을 코드 상단으로 끌어올리는 것처럼 동작하지만, var는 선언만 호이스팅되어 초기화 전에 undefined가 되며, let과 const는 TDZ로 인해 초기화 전에 접근하면 ReferenceError를 발생시킵니다.

</details>
<br/>

<details>
<summary>  자바스크립트 배열에 대해서 설명해주세요. </summary>
<br/>
자바스크립트의 배열(Array)은 순서가 있는 리스트형 객체로, 여러 값을 하나의 자료구조에 저장할 수 있습니다.

배열은 제로 인덱스 기반으로, 배열의 각 값은 인덱스를 통해 접근할 수 있습니다. 자바스크립트 배열은 `동적 배열`로, 크기가 고정되어 있지 않고, 요소를 자유롭게 추가하거나 제거할 수 있는 유연성을 제공합니다.

배열의 선언은 간단하며, 다양한 데이터 타입을 함께 저장할 수 있습니다.

```
const array = [1, 'apple', true, { key: 'value' }];

```

이 배열은 숫자, 문자열, 불리언, 객체 등 다양한 타입을 저장할 수 있으며, 배열의 첫 번째 요소는 array[0]으로, 두 번째 요소는 array[1]과 같이 접근할 수 있습니다.

자바스크립트 배열의 중요한 특징 중 하나는 `동적 배열`이라는 점입니다. 이는 배열의 크기를 미리 지정하지 않아도 되고, 요소를 추가할 때마다 배열의 크기가 자동으로 조정됩니다.

```
const arr = [1, 2, 3];
arr.push(4); // 배열의 끝에 요소 추가
console.log(arr); // [1, 2, 3, 4]

```

또한, 배열의 특정 인덱스에 값을 할당하면, 배열이 자동으로 확장됩니다.

```
arr[5] = 6;
console.log(arr); // [1, 2, 3, undefined, undefined, 6]
console.log(arr.length); // 6

```

이처럼 자바스크립트 배열은 동적으로 크기가 조정되며, 요소를 추가하거나 특정 인덱스에 값을 할당하면, 배열은 자동으로 확장됩니다.

자바스크립트 배열의 length 속성은 배열의 크기를 나타내며, 배열에 요소가 추가되거나 제거될 때 동적으로 변경됩니다.

또한, 배열은 자바스크립트의 객체와 유사한 방식으로 관리되며, 해시 테이블과 같은 자료구조로 구현되어 있습니다. 이 덕분에 배열 요소들은 메모리 상에서 연속적이지 않아도 되며, 배열 크기를 미리 지정하지 않고 유연하게 사용할 수 있습니다.

정리하자면, 자바스크립트 배열은 다양한 데이터 타입을 담을 수 있는 유연한 `리스트형 객체`로, 동적 배열이라는 특징을 가지며, 요소를 추가하거나 제거할 때마다 배열 크기가 자동으로 조정됩니다. 또한, 여러 reduce나 map 등 다양한 내장 메서드를 통해 배열을 쉽게 조작할 수 있는 강력한 기능을 제공합니다.

</details>
<br/>

<details>
<summary>  자바스크립트 함수에 대해서 설명해주세요. </summary>
<br/>
자바스크립트 함수는 `일급 객체`로 취급되며, 여러 독특한 특징을 가지고 있습니다. 일급 객체로서의 특징은 자바스크립트 함수가 변수에 할당되거나, 다른 함수의 인자로 전달되거나, 함수에서 반환될 수 있다는 점입니다.

이를 통해 자바스크립트는 매우 유연하고, 고차 함수를 포함한 다양한 패턴을 구현할 수 있습니다.

자바스크립트 함수의 주요 특징은 여러가지가 있는데요.

**첫번째로 `일급 객체`를 말씀 드릴 수 있습니다.**

자바스크립트에서 함수는 값처럼 취급될 수 있으며, 변수에 할당하거나, 다른 함수의 인자로 전달하거나, 함수의 반환값으로 사용할 수 있습니다.

```
const sayHello = function() { return 'Hello'; };
console.log(sayHello()); // 'Hello'

const executeFunction = function(fn) {
  return fn();
};
console.log(executeFunction(sayHello)); // 'Hello'

```

**두번째로는 `익명 함수`와 `함수 표현식`입니다.**

자바스크립트에서는 이름 없는 함수를 정의할 수 있습니다. 익명 함수는 함수 표현식에서 주로 사용되며, 필요에 따라 함수에 이름을 지정하지 않아도 됩니다.

```
const add = function(a, b) {
  return a + b;
};
console.log(add(2, 3)); // 5

```

**세번째로는 `호이스팅`입니다.** 함수 선언은 코드가 실행되기 전에 호이스팅되어, 함수 선언 이전에 호출할 수 있습니다. 반면, 함수 표현식은 변수에 할당된 후에야 사용할 수 있습니다.

```
console.log(declaredFunction()); // 'Declared Function'
function declaredFunction() {
  return 'Declared Function';
}

// 함수 표현식은 할당 후에만 사용할 수 있음
const expressedFunction = function() {
  return 'Expressed Function';
};
console.log(expressedFunction()); // 'Expressed Function'

```

**네번째는 `클로저`입니다.**

자바스크립트 함수는 클로저를 지원합니다. 클로저는 함수가 **자신이 선언된 환경(스코프)** 을 기억하고, 그 외부 스코프에 접근할 수 있는 기능입니다. 이를 통해 함수는 자신이 선언된 스코프 내의 변수를 참조하고 유지할 수 있습니다.

```
function outer() {
  const outerVar = 'I am outer!';

  return function inner() {
    return outerVar; // 외부 변수에 접근 가능
  };
}
const innerFunction = outer();
console.log(innerFunction()); // 'I am outer!'

```

**다음으로는 `고차 함수`입니다.** 자바스크립트에서는 함수가 일급 객체이기 때문에, 고차 함수, 즉 다른 함수를 인자로 받거나 반환하는 함수를 정의할 수 있습니다. 이는 함수형 프로그래밍 패턴을 가능하게 합니다.

```
function multiplyBy(factor) {
  return function(num) {
    return num * factor;
  };
}
const double = multiplyBy(2);
console.log(double(5)); // 10

```

**마지막으로 화살표 함수입니다.**

화살표 함수는 더 간결한 문법을 제공하고, 특히 this 바인딩에서 기존 함수와 다른 동작을 합니다. 화살표 함수는 선언된 위치의 this 값을 유지하므로, 일반 함수와 달리 별도로 this를 바인딩할 필요가 없습니다.

```
const obj = {
  value: 42,
  method: function() {
    setTimeout(() => {
      console.log(this.value); // 42 (Arrow 함수는 obj의 this를 유지)
    }, 1000);
  }
};
obj.method();

```

요약하자면, 자바스크립트 함수는 일급 객체로써 다루어지며, 클로저, 고차 함수, 화살표 함수 등 강력한 기능들을 제공합니다.

</details>
<br/>

<details>
<summary>  script 태그에서 async와 defer의 차이점에 대해서 설명해주세요. </summary>
<br/>
먼저, 두 속성 모두 스크립트를 비동기적으로 로드한다는 공통점이 있습니다. 하지만 실행 시점에서 중요한 차이가 있습니다.

**async** 속성의 경우

1. 스크립트를 비동기적으로 다운로드합니다.
2. 다운로드가 완료되면 즉시 실행됩니다.
3. HTML 파싱과 병렬로 진행되지만, 스크립트 실행 시 HTML 파싱이 잠시 중단됩니다.
4. 여러 async 스크립트가 있을 경우, 다운로드가 완료되는 순서대로 실행됩니다.

이러한 특징들이 존재합니다.

**defer** 속성의 경우에는

1. 스크립트를 비동기적으로 다운로드합니다.
2. **HTML 문서 파싱이 완전히 끝난 후에 실행**됩니다.
3. **DOMContentLoaded 이벤트 발생 직전에 실행**됩니다.
4. 여러 defer 스크립트가 있을 경우, **HTML에 작성된 순서대로 실행**됩니다.

따라서, **실행 순서가 중요한 스크립트나 메인 어플리케이션의 로직을 담고 있는 스크립트의 경우 defer를 사용하고**, 독립적으로 실행되는 스크립트의 경우 (예들 들면 Google Analytics 같은 분석 도구) async를 사용하는 것이 적절합니다.

이러한 차이를 이해하고 적절히 활용하면 웹 페이지의 로딩 성능을 최적화하는 데 큰 도움이 됩니다.

</details>
<br/>
