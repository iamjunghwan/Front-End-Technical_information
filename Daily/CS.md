<details>
<summary>👋 TCP 3-way handshake 과정에 대해서 설명해주세요.

 </summary>
<br/>
3-way handshake는 TCP 연결을 수립하는 과정으로, 클라이언트와 서버 간에 신뢰성 있는 연결을 보장하기 위해 존재합니다. 이 과정은 크게 세 단계로 구성됩니다.

첫째, 클라이언트가 서버에 SYN 패킷을 보내면서 연결 요청을 시작합니다. 이 패킷에는 클라이언트의 초기 시퀀스 번호(Initial Sequence Number)가 포함됩니다.

둘째, 서버는 클라이언트의 SYN을 받고 SYN-ACK 패킷으로 응답합니다. 서버가 클라이언트로부터 요청을 잘 받았다고 확인하고, 데이터를 주고받을 준비가 되었음을 알리는 과정입니다. 이 패킷에는 클라이언트의 시퀀스 번호에 1을 더한 값(ACK)과 서버 자신의 초기 시퀀스 번호(SYN)가 포함됩니다.

마지막으로, 클라이언트는 서버의 SYN-ACK를 받고 ACK 패킷을 보냅니다. 이 패킷에는 서버의 시퀀스 번호에 1을 더한 값이 포함됩니다.

이 세 단계가 완료되면 TCP 연결이 수립되어 신뢰성 있는 데이터 전송이 가능해집니다.

3-way handshake 과정이 필요한 이유는 무엇인가요? 🤔
TCP는 신뢰성 있는 데이터 전송을 보장해야 하기 때문에, 송신자와 수신자가 서로를 확인하고 준비 상태를 점검하는 3-way handshake 과정을 거치는 것입니다. 단순히 패킷을 한 번 보내는 것이 아니라, 세 번의 패킷 교환을 통해 실제 연결이 정상적으로 설정되었는지 확인할 수 있습니다. 만약 이 과정이 없다면, 네트워크 지연이나 패킷 손실로 인해 잘못된 연결이 설정될 가능성이 있습니다.

3-way handshake 없이 데이터를 전송할 수 있는 프로토콜도 있나요? 🧐
네, 대표적으로 UDP가 있습니다. UDP는 TCP와 달리 연결을 설정하는 과정 없이 데이터를 바로 전송합니다. 따라서 속도는 빠르지만 신뢰성이 보장되지 않습니다. 영상 스트리밍이나 온라인 게임처럼 실시간성이 필요한 경우에는 UDP를 사용합니다.

</details>
<br/>

<details>
<summary>
🫥 HTTP란 무엇인지 설명해 주세요.
 </summary>
<br/>
**HTTP(Hypertext Transfer Protocol) 는 웹 상에서 클라이언트와 서버 간 데이터를 주고받는 데 사용되는 통신 규약**입니다. 클라이언트가 서버에 요청을 보내고, 서버가 이에 대한 응답을 반환하는 방식으로 동작합니다. HTTP는 **비연결성(stateless)** 을 특징으로 하여 한 번의 요청-응답이 끝나면 연결이 종료됩니다. 또한, 통신이 안전하게 연결될 수 있도록 TCP 연결을 사용합니다.

HTTP는 HTML, JSON 등 **다양한 데이터 포맷**을 전달할 수 있습니다. 요청과 응답에는 **URL 경로, 각종 메서드, 상태 코드와 헤더** 등 정해진 몇 가지 정보를 포함합니다.

HTTP의 보안을 강화한 버전인 **HTTPS(Hypertext Transfer Protocol Secure)** 는 HTTP에 TLS/SSL 프로토콜에 따라 데이터를 암호화하여 전송합니다. 이를 통해 보안 상 중요한 정보들을 안전하게 보호하여 통신을 주고 받습니다.

## **HTTP와 함께 자주 언급되는 RESTFul API은 무엇인가요? 🤔**

**RESTful API는 REST(Representational State Transfer) 스타일을 준수하여 설계된 API**를 의미합니다. 여기서 **REST는 웹의 리소스를 클라이언트와 서버가 일관된 방식으로 처리할 수 있도록 하는 설계 원칙**입니다.

기본적으로 REST에서는 리소스를 고유한 URI로 표현하고, HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용해 행위를 표현합니다. 예를 들어, /users URI에 GET 요청을 보내면 사용자 목록을 가져오는 API로 동작할 수 있습니다.

다음은 REST의 핵심 규칙들입니다.

1. **클라이언트-서버 분리**: 클라이언트와 서버 간 역할을 명확히 분리합니다.
2. **무상태성(Stateless)**: 서버는 클라이언트의 상태를 저장하지 않으며, 각 요청은 독립적으로 처리합니다.
3. **일관된 인터페이스(Uniform Interface)**: 고유한 URI로 리소스를 식별하고 일관된 인터페이스를 통해 클라이언트와 서버가 간단하고 예측 가능하게 통신할 수 있게 합니다.
4. **캐시 가능성**: 가능하다면, 서버의 응답 시간을 개선하기 위해 리소스 캐싱을 지원합니다.
</details>
<br/>

<details>
<summary>
😄 네트워크 통신에서 Body(Payload)와 Header의 차이는 무엇인가요?
 </summary>
<br/>
Body와 Header의 가장 큰 차이는 **정보(데이터)의 역할**입니다.

**Header**는 **데이터의 메타 정보**를 담습니다. 즉, 데이터 자체가 아니라 데이터에 대한 컨텍스트 정보를 포함합니다. 이로써 **수신자가 데이터를 어떻게 처리해야 할지 지침을 제공**하는 역할을 합니다. 예를 들어, HTTP 요청이나 응답에서 Header에는 Content-Type, Authorization, Cache-Control과 같은 정보가 포함됩니다. 이는 정보의 유형, 인증 정보, 캐시 설정 등 컨텍스트 정보를 전달합니다.

반면 **Body는 전송하려는 실제 데이터**를 의미합니다. HTTP 요청에서 서버로 전달하는 JSON 데이터나 폼 데이터가 이에 해당됩니다. 일반적으로 헤더에 비해 복잡하고 용량이 큰 데이터를 포함합니다.

즉, Header는 네트워크 통신에서 안내 역할을, Body는 본질적인 데이터를 전달하는 역할을 맡고 있습니다. 이 둘의 조화가 효율적인 통신을 가능하게 합니다.

## **Header 크기에 제한이 있나요? 🤔**

HTTP 표준을 정의하는 문서인 HTTP RFC에 따르면, Header의 명시적인 크기 제한은 정해져 있지 않습니다. 다만, Apache, Nginx와 같은 웹서버 단에서 Header의 크기를 제한하고 있는 경우가 많습니다. 일반적으로, 8KB-16KB로 설정되어 있습니다. 이러한 제한값을 초과할 경우, 일반적으로 응답코드 413(Content Too Large)를 응답합니다.

</details>
<br/>
