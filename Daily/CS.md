<details>
<summary>👋 TCP 3-way handshake 과정에 대해서 설명해주세요.

 </summary>
<br/>
3-way handshake는 TCP 연결을 수립하는 과정으로, 클라이언트와 서버 간에 신뢰성 있는 연결을 보장하기 위해 존재합니다. 이 과정은 크게 세 단계로 구성됩니다.

첫째, 클라이언트가 서버에 SYN 패킷을 보내면서 연결 요청을 시작합니다. 이 패킷에는 클라이언트의 초기 시퀀스 번호(Initial Sequence Number)가 포함됩니다.

둘째, 서버는 클라이언트의 SYN을 받고 SYN-ACK 패킷으로 응답합니다. 서버가 클라이언트로부터 요청을 잘 받았다고 확인하고, 데이터를 주고받을 준비가 되었음을 알리는 과정입니다. 이 패킷에는 클라이언트의 시퀀스 번호에 1을 더한 값(ACK)과 서버 자신의 초기 시퀀스 번호(SYN)가 포함됩니다.

마지막으로, 클라이언트는 서버의 SYN-ACK를 받고 ACK 패킷을 보냅니다. 이 패킷에는 서버의 시퀀스 번호에 1을 더한 값이 포함됩니다.

이 세 단계가 완료되면 TCP 연결이 수립되어 신뢰성 있는 데이터 전송이 가능해집니다.

3-way handshake 과정이 필요한 이유는 무엇인가요? 🤔
TCP는 신뢰성 있는 데이터 전송을 보장해야 하기 때문에, 송신자와 수신자가 서로를 확인하고 준비 상태를 점검하는 3-way handshake 과정을 거치는 것입니다. 단순히 패킷을 한 번 보내는 것이 아니라, 세 번의 패킷 교환을 통해 실제 연결이 정상적으로 설정되었는지 확인할 수 있습니다. 만약 이 과정이 없다면, 네트워크 지연이나 패킷 손실로 인해 잘못된 연결이 설정될 가능성이 있습니다.

3-way handshake 없이 데이터를 전송할 수 있는 프로토콜도 있나요? 🧐
네, 대표적으로 UDP가 있습니다. UDP는 TCP와 달리 연결을 설정하는 과정 없이 데이터를 바로 전송합니다. 따라서 속도는 빠르지만 신뢰성이 보장되지 않습니다. 영상 스트리밍이나 온라인 게임처럼 실시간성이 필요한 경우에는 UDP를 사용합니다.

</details>
<br/>

<details>
<summary>
🫥 HTTP란 무엇인지 설명해 주세요.
 </summary>
<br/>
**HTTP(Hypertext Transfer Protocol) 는 웹 상에서 클라이언트와 서버 간 데이터를 주고받는 데 사용되는 통신 규약**입니다. 클라이언트가 서버에 요청을 보내고, 서버가 이에 대한 응답을 반환하는 방식으로 동작합니다. HTTP는 **비연결성(stateless)** 을 특징으로 하여 한 번의 요청-응답이 끝나면 연결이 종료됩니다. 또한, 통신이 안전하게 연결될 수 있도록 TCP 연결을 사용합니다.

HTTP는 HTML, JSON 등 **다양한 데이터 포맷**을 전달할 수 있습니다. 요청과 응답에는 **URL 경로, 각종 메서드, 상태 코드와 헤더** 등 정해진 몇 가지 정보를 포함합니다.

HTTP의 보안을 강화한 버전인 **HTTPS(Hypertext Transfer Protocol Secure)** 는 HTTP에 TLS/SSL 프로토콜에 따라 데이터를 암호화하여 전송합니다. 이를 통해 보안 상 중요한 정보들을 안전하게 보호하여 통신을 주고 받습니다.

## **HTTP와 함께 자주 언급되는 RESTFul API은 무엇인가요? 🤔**

**RESTful API는 REST(Representational State Transfer) 스타일을 준수하여 설계된 API**를 의미합니다. 여기서 **REST는 웹의 리소스를 클라이언트와 서버가 일관된 방식으로 처리할 수 있도록 하는 설계 원칙**입니다.

기본적으로 REST에서는 리소스를 고유한 URI로 표현하고, HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용해 행위를 표현합니다. 예를 들어, /users URI에 GET 요청을 보내면 사용자 목록을 가져오는 API로 동작할 수 있습니다.

다음은 REST의 핵심 규칙들입니다.

1. **클라이언트-서버 분리**: 클라이언트와 서버 간 역할을 명확히 분리합니다.
2. **무상태성(Stateless)**: 서버는 클라이언트의 상태를 저장하지 않으며, 각 요청은 독립적으로 처리합니다.
3. **일관된 인터페이스(Uniform Interface)**: 고유한 URI로 리소스를 식별하고 일관된 인터페이스를 통해 클라이언트와 서버가 간단하고 예측 가능하게 통신할 수 있게 합니다.
4. **캐시 가능성**: 가능하다면, 서버의 응답 시간을 개선하기 위해 리소스 캐싱을 지원합니다.
</details>
<br/>

<details>
<summary>
😄 네트워크 통신에서 Body(Payload)와 Header의 차이는 무엇인가요?
 </summary>
<br/>
Body와 Header의 가장 큰 차이는 **정보(데이터)의 역할**입니다.

**Header**는 **데이터의 메타 정보**를 담습니다. 즉, 데이터 자체가 아니라 데이터에 대한 컨텍스트 정보를 포함합니다. 이로써 **수신자가 데이터를 어떻게 처리해야 할지 지침을 제공**하는 역할을 합니다. 예를 들어, HTTP 요청이나 응답에서 Header에는 Content-Type, Authorization, Cache-Control과 같은 정보가 포함됩니다. 이는 정보의 유형, 인증 정보, 캐시 설정 등 컨텍스트 정보를 전달합니다.

반면 **Body는 전송하려는 실제 데이터**를 의미합니다. HTTP 요청에서 서버로 전달하는 JSON 데이터나 폼 데이터가 이에 해당됩니다. 일반적으로 헤더에 비해 복잡하고 용량이 큰 데이터를 포함합니다.

즉, Header는 네트워크 통신에서 안내 역할을, Body는 본질적인 데이터를 전달하는 역할을 맡고 있습니다. 이 둘의 조화가 효율적인 통신을 가능하게 합니다.

## **Header 크기에 제한이 있나요? 🤔**

HTTP 표준을 정의하는 문서인 HTTP RFC에 따르면, Header의 명시적인 크기 제한은 정해져 있지 않습니다. 다만, Apache, Nginx와 같은 웹서버 단에서 Header의 크기를 제한하고 있는 경우가 많습니다. 일반적으로, 8KB-16KB로 설정되어 있습니다. 이러한 제한값을 초과할 경우, 일반적으로 응답코드 413(Content Too Large)를 응답합니다.

</details>
<br/>

<details>
<summary>🛜 OSI 7계층에 대해서 설명해주세요. </summary>
<br/>
OSI 7계층은 국제표준화기구(ISO)에서 제시한 국제 표준 규약으로, 네트워크 통신이 일어나는 과정을 7개의 계층으로 나누어 정의했습니다. 각 계층은 하위 계층의 기능만을 이용하며 상위 계층에게 기능을 제공합니다.
1계층 물리 계층(Physical Layer)은 실제로 데이터를 전송하는 하드웨어적인 부분을 담당합니다. 데이터를 0과 1의 신호로 변환해 전기, 빛, 무선 주파수 등을 통해 전달하는 역할을 합니다. 흔히 볼 수 있는 케이블, 안테나 같은 장비가 물리 계층에서 동작합니다.
2계층 데이터 링크 계층(Data Link Layer)은 신뢰성 있는 전송을 보장하기 위한 계층입니다. 물리 계층에서 전송된 데이터를 프레임 단위로 관리하고, 통신 오류를 감지 및 수정하는 역할을 수행합니다. 데이터 링크 계층에서는 각 장치가 서로를 구별할 수 있도록 MAC 주소를 가지고 통신합니다. 대표적으로 스위치가 이 계층에서 동작합니다.
3계층 네트워크 계층(Network Layer)은 데이터를 목적지까지 정확하게 전달하는 역할을 합니다. 쉽게 말해, 네트워크 상에서 최적의 길을 찾아 패킷을 목적지까지 보내는 기능을 합니다. 여기에는 라우터와 같은 장치나 IP와 같은 프로토콜이 포함됩니다.
4계층 전송 계층(Transport Layer)은 양 끝단의 사용자들이 신뢰성 있는 데이터를 주고 받을 수 있도록 해주는 역할을 합니다. 전송 계층은 오류 검출 및 복구, 흐름 제어, 순서 보장과 같은 일들에 중점을 둡니다. 대표적으로 TCP와 UDP가 전송 계층에 속합니다.
5계층 세션 계층(Session Layer)은 애플리케이션 간의 통신 연결을 설정하고 유지하는 역할을 합니다. 연결이 끊어졌을 때 다시 복구하는 기능도 포함됩니다. 대표적으로 RPC와 NetBIOS가 세션 계층에 속합니다.
6계층 표현 계층(Presentation Layer)은 데이터 표현 방식을 다룹니다. 하위 계층으로부터 온 데이터를 사용자가 이해할 수 있는 형태로 만들기 위해 데이터 형식을 변환합니다. 혹은, 암호화 및 복호화, 압축과 같은 작업을 수행합니다. 예를 들면, MIME 인코딩, ASCII 인코딩 등의 작업이 표현 계층에서 이루어집니다.
7계층 응용 계층(Application Layer)은 사용자와 직접 접하여 네트워크에 접근할 수 있게 해주는 역할을 합니다. 유저가 사용하는 웹 브라우저, 이메일, 메신저 같은 애플리케이션이 이 계층에서 동작합니다. 대표적으로 HTTP, SMTP, FTP 같은 프로토콜이 응용 계층에 포함됩니다.
OSI 7계층의 필요성을 설명해주세요. 🤔
OSI 7계층은 서로 다른 시스템끼리 올바르게 통신할 수 있도록 표준화된 규칙을 제시해줍니다. 더불어, 전체 통신 흐름을 이해하기 용이하게 해주고, 계층을 명확히 나눔으로써 문제가 발생했을 때 원인을 좁히고 해결하는 데 도움을 줍니다.

</details>
<br/>

<details>
<summary>〰️ 멀티 프로세스와 멀티 스레드에 대해 설명해주세요.</summary>
<br/>
멀티 프로세스와 멀티 스레드는 컴퓨터 자원을 효율적으로 활용하고, 상황에 따라 작업의 안정성 또는 처리 속도를 개선하기 위한 기법입니다.

## 멀티 프로세스

먼저, 멀티 프로세스는 하나의 프로그램이 여러 개의 프로세스를 생성해, 각각이 독립적으로 실행되는 구조를 의미합니다. 각 프로세스는 자신만의 메모리 공간을 가지고 있습니다. 그래서 하나의 프로세스에서 문제가 생기더라도 다른 프로세스에는 영향을 미치지 않아 높은 안정성을 가집니다. 이처럼 격리된 실행 환경은 보안성과 충돌 방지에 강점을 보입니다.

대표적인 예시로는 크롬 브라우저의 탭 구조가 있습니다. 각 탭이 별도의 프로세스로 실행되기 때문에, 한 탭에서 무한 루프나 오류가 발생하더라도 브라우저 전체가 멈추지 않고, 해당 탭만 종료됩니다.

하지만 멀티 프로세스에는 단점도 존재합니다. 프로세스마다 메모리를 별도로 할당받기 때문에 시스템 자원 소모가 큽니다. 또한, 서로 다른 프로세스 간 데이터를 주고받기 위한 IPC(Inter-Process Communication)도 복잡하고 비용이 높습니다.

## 멀티 스레드

반면, 멀티 스레드는 하나의 프로세스 내부에서 여러 스레드가 동시에 작업을 수행하는 구조입니다. 이 스레드들은 하나의 메모리 공간을 공유하고, 가볍고 빠른 작업 분할이 가능하다는 점에서 성능 효율이 높습니다.

예를 들어 서버에서 네트워크 요청을 동시에 처리하거나, 게임에서 여러 캐릭터의 움직임을 병렬로 계산할 때 효과적입니다.

하지만 멀티 스레드 구조에서는 공유 자원에 대한 충돌 문제가 존재합니다. 두 스레드가 동시에 같은 메모리 주소를 수정하려고 할 때 데이터가 꼬일 수 있으며, 이를 방지하기 위해 락이나 세마포어 같은 동기화 기술을 사용해야 합니다. 이러한 동기화 처리에는 추가적인 코드 복잡도와 성능 저하의 위험도 따라옵니다.

</details>
<br/>

<details>
<summary> 🍪 쿠키와 세션 </summary>
<br/>
쿠키와 세션은 클라이언트와 서버 간의 상태를 유지하기 위해 사용하는 대표적인 방식들입니다. 웹은 기본적으로 상태를 저장하지 않는 Stateless한 구조이기 때문에, 사용자의 로그인 정보나 장바구니와 같은 클라이언트 정보를 유지하려면 별도의 상태 관리 방식이 필요합니다. 이때 주로 활용되는 방식이 쿠키와 세션입니다.

먼저, **쿠키는 클라이언트 측에 저장되는 데이터**입니다. 서버가 클라이언트에게 응답할 때 `Set-Cookie` 헤더를 통해 데이터를 전달하고, 이후 클라이언트는 요청 시 해당 쿠키를 자동으로 포함하여 서버로 전송하게 됩니다. 쿠키는 브라우저에 저장되기 때문에 서버에서는 별도의 저장 공간을 차지하지 않으며, 지속적인 상태 유지가 가능합니다. 유효 기간을 설정하여 자동 만료되도록 할 수도 있습니다. 쿠키는 클라이언트 측에 상태를 저장하기 때문에 서버는 세션처럼 별도의 저장소를 유지하지 않아도 된다는 장점이 있습니다. 하지만 탈취될 경우 쿠키에 포함된 개인정보가 노출되는 보안 상 단점이 존재합니다.

반면 세션은 **서버 측에 저장되는 데이터**입니다. 사용자가 서버에 처음 인증을 수행할 때 고유한 세션 ID가 생성되고, 이 ID가 클라이언트에 전달됩니다. 이후 클라이언트는 이 세션 ID를 서버로 전송하며, 서버는 해당 ID를 통해 사용자 상태 정보를 조회합니다. 세션은 서버에 저장되기 때문에 보안 면에서 쿠키보다 안전하지만, 서버 자원을 차지하고 확장에 불리하다는 단점이 있습니다.

## 쿠키 대신 LocalStorage나 SessionStorage를 사용해도 되지 않나요?

말씀하신대로 LocalStorage와 SessionStorage는 모두 브라우저에 데이터를 저장하는 방식으로, 쿠키와 유사한 점이 있습니다.

하지만 자동으로 서버에 전송되지 않는다는 차이점이 있습니다. 또한, 두 저장소는 자바스크립트를 통해 접근이 가능하므로 XSS에 더욱 취약할 수 있습니다. 반면, 쿠키는 매 요청에 자동으로 포함되며 `HttpOnly` 설정을 통해 XSS를 예방할 수 있습니다. 따라서 인증 상태를 관리할 때에는 쿠키를 사용하는 경우가 많습니다.

## 로그인 구현 시 세션 방식은 주로 어떤 경우에 채택하나요?

보안의 중요도가 높은 서비스에서 많이 사용합니다. 세션 ID는 서버에 저장되고 클라이언트에는 참조만 전달되어 토큰 기반 방식보다 탈취 시 위험성이 낮고, 대응에도 용이합니다.

또한, 원격 로그아웃 기능이 필요한 경우에도 사용됩니다. 예를 들어, 동시 로그인 가능 기기 수를 제한해야 하거나, 강제 로그아웃을 구현해야 하는 경우가 있습니다. 이처럼 서버 측에서 사용자별 로그인 상태를 관리해야 하는 경우 유용하게 활용될 수 있습니다.

다만, 서버 자원을 많이 사용하고 분산 시스템에서는 세션 동기화가 필요하다는 단점이 있으므로 트레이드 오프를 고려하여 선택해야 합니다.

</details>
<br/>
