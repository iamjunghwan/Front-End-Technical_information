<details>
<summary>🌹 CSS Flexbox와 Grid의 차이점에 대해서 설명해주세요.
 </summary>
<br/>
**Flexbox**와 **Grid**는 페이지에서 **레이아웃을 구성할 때 자주 사용되는 CSS 속성**입니다. 두 속성 모두 화면 요소를 배치하고 정렬하는 데에 사용되지만 몇가지 차이점이 존재합니다.

첫번째로 Flexbox는 **1차원 레이아웃이지만, Grid는 2차원 레이아웃**입니다.

**Flexbox**는 **1차원 레이아웃 속성**으로, row 또는 column 중 하나를 기준으로 요소를 정렬하고 배치하는 데 최적화되어 있습니다. 주로 행이나 열 중 하나의 방향으로 정렬해야 할 때 유용하며, 복잡한 행과 열을 모두 포함하는 레이아웃에서는 다소 한계가 있습니다.

반면 **Grid**는 **2차원 레이아웃 속성**으로, 행과 열을 모두 사용해 요소를 배치할 수 있습니다. 따라서 복잡한 레이아웃을 구성하거나, 웹페이지의 전체적인 구조를 잡는 데 적합합니다.

두번째는 **사용 목적의 차이**입니다.

**Flexbox**는 **콘텐츠 중심으로, 콘텐츠가 추가되거나 줄어들 때 유연하게 대처**하기 좋습니다. 예를 들어, 수평 또는 수직 방향으로 콘텐츠를 정렬하고 간격을 조절하는 데 유용하며, 버튼 그룹, 내비게이션 바 등 한 줄의 콘텐츠가 주가 되는 구성에 적합합니다.

**Grid**는 **레이아웃 중심으로 페이지 구조를 구성하는 데 최적화**되어 있습니다. 예를 들어, 카드 레이아웃, 갤러리 형식 등 명확하게 구분된 영역을 기반으로 레이아웃을 구성할 때 Grid가 효과적입니다.

마지막으로는 **기본 동작의 차이입니다**.

**Flexbox**에서는 주로 요소가 **컨테이너의 크기나 위치에 맞춰 자동으로 정렬**됩니다. Flexbox의 justify-content와 align-items 속성을 사용해, 주 축 방향으로 요소들을 배치하고 여백을 조절할 수 있습니다.

**Grid**는 **행과 열을 사전에 정의하고 그 격자(grid cell)에 요소를 배치하는 방식**입니다. Grid에서는 grid-template-rows, grid-template-columns와 같은 속성으로 행과 열의 크기를 정의하고, 각 요소의 위치를 세밀하게 설정할 수 있습니다.

</details>
<br/>

<details>
<summary>
😄 제로 런타임 css란 무엇인가요?
 </summary>
<br/>
**제로 런타임 CSS**는 CSS-in-JS의 단점을 보완하기 위해 등장한 방식입니다. 기존에 많이 쓰이던 CSS-in-JS 방식은 스타일을 컴포넌트 안에서 작성해서 동적으로 생성합니다. 이러한 방식은 런타임에서 CSS를 만들다 보니 성능 문제가 생길 가능성이 있습니다.

예를 들어, 사용자가 페이지를 로딩할 때마다 CSS를 동적으로 계산해서 DOM에 삽입하면, 브라우저가 이를 처리하는 데 시간이 걸리게 됩니다. 특히, 앱이 커질수록 성능이 떨어질 수 있고, CSS를 캐싱하기도 어려운 문제가 존재합니다. 그래서 나온 방식이 **빌드 시점에 CSS를 미리 다 만들어 놓는 제로 런타임 CSS 방식**입니다.

기존 CSS-in-JS 방식은 사용자가 앱을 실행할 때 CSS를 동적으로 생성했는데, 이 과정이 성능에 부담을 주는 경우가 있었습니다. 특히 렌더링이 복잡한 페이지에서 스타일 생성이 많아질수록 느려질 가능성이 큽니다. 동적으로 생성되는 CSS는 정적인 파일처럼 브라우저가 캐싱할 수 없어서, 매번 렌더링 될때마다 새롭게 계산해야 하기도 합니다. 또한 런타임에서 필요한 모든 스타일을 생성하려다 보니, 사용되지 않는 CSS 코드까지 포함되는 경우가 발생합니다.

반면에 제로 런타임 CSS는 앱이 실행되기 전에, 빌드 시점에 모든 스타일을 정적인 CSS 파일로 변환하는 방식입니다. 이렇게 된다면 런타임에 추가로 CSS를 생성하지 않으니 로딩 속도가 더 빠르고, 사용되지 않는 CSS는 빌드 과정에서 제거되기 때문에 최종 파일 크기가 작아집니다.

## **제로 런타임 CSS의 단점은 무엇이 있나요? 🤔**

런타임에서 **동적으로 생성해야 하는 스타일을 구현하기가 까다롭습니다**. 예를 들어, 사용자 입력값에 따라 스타일이 달라지는 경우엔 추가 로직을 작성해주어야 합니다. 또한 스타일을 빌드 시점에 모두 처리해야 하다 보니, 빌드 시간이 기존보다 길어질 수 있습니다.

</details>
<br/>

<details>
<summary>
🦿 길이 단위 px, em, rem에 대해 각각 설명해주세요.
 </summary>
<br/>
**px은 화면의 물리적인 픽셀 단위를 기준으로 한 고정 단위**입니다. 이 값은 절대적인 크기를 나타내며, 요소의 크기가 고정되어 디바이스의 해상도나 사용자 설정에 영향을 받지 않습니다. 예를 들어, `font-size: 16px`으로 설정하면 항상 16픽셀 크기로 표시됩니다. 픽셀 단위는 간단하고 정확한 제어를 제공하지만, 사용자의 접근성 설정(예: 브라우저에서 텍스트 크기 확대)에 따라 조정되지 않아 유연성이 떨어질 수 있습니다.

**em은 해당 요소에 현재 적용된(즉, 부모 요소 또는 현재 요소의) font-size를 기준으로 하는 상대 단위**입니다. 기본적으로, 브라우저의 초기 폰트 크기가 16px이므로, 상속받은 기본값이 없을 경우 1em은 16px로 계산됩니다. 그러나 상위 요소에 따라 상대적으로 크기가 결정되므로, 계층 구조가 깊어질수록 값이 누적되어 예기치 않은 크기로 설정될 수 있습니다. 예를 들어, 부모 요소가 `font-size: 20px`이고 자식 요소가 `font-size: 1.5em`으로 설정되면, 자식의 실제 폰트 크기는 30px이 됩니다.

**rem은 root em을 의미하며, 최상위 HTML 요소의 font-size를 기준으로 계산**됩니다. 이는 em과 달리 요소 계층에 따라 크기가 누적되지 않으며, 전역적인 기준을 따릅니다. 예를 들어, HTML의 font-size가 16px로 설정되어 있다면, 1rem은 항상 16px로 계산됩니다. 따라서 rem은 전역적으로 일관된 상대적인 크기를 설정할 때 유용하며, 접근성 측면에서도 사용자 설정에 잘 대응한다는 장점이 있습니다.

## **em과 rem이 모두 상대 단위라면, rem을 사용하지 않고 em을 사용해야 하는 경우는 언제인가요? 🤔**

rem을 항상 사용하지 않고 em을 사용하는 경우는 **특정 상황에서 해당 컨텍스트에 따라 상대적인 크기를 지정해야 하는 경우**입니다. em은 부모 요소 또는 현재 요소의 font-size를 기준으로 크기가 결정되므로, 구성 요소 간의 비례적인 크기를 쉽게 조정할 수 있습니다. 예를 들어, 버튼 안의 텍스트와 패딩을 비율로 정의하고 싶을 때, 각각의 속성에 em을 사용하면 텍스트 크기를 조정될 때 패딩이 자연스럽게 비례적으로 조정되도록 할 수 있습니다.

반면, rem은 루트 요소를 기준으로 고정된 상대 크기를 제공하기 때문에 전역적인 일관성에는 적합하지만, 특정 컨텍스트에 맞춘 비례 조정이 필요한 경우에는 부적합할 수 있습니다.

</details>
<br/>

<details>
<summary>🌫️ box-sizing 속성에 대해 설명해주세요.</summary>
<br/>
`box-sizing`은 **CSS에서 요소의 크기를 어떻게 계산할지를 결정하는 속성**입니다. 레이아웃을 스타일링할 때 예상치 못한 크기(너비, 높이) 변화가 발생하곤 하는데요. 그런 상황에서 `box-sizing` 속성이 도움이 될 수 있습니다.

`box-sizing`에는 두 가지 옵션이 있습니다. 바로, `content-box`와 `border-box`입니다.

### **1. `box-sizing: content-box` (기본값)**

`content-box`는 `box-sizing` 속성의 기본값으로, 적용 시 요소의 `width`와 `height` 값이 내용 영역만의 크기를 나타냅니다. 즉, `width`와 `height`는 요소의 실제 콘텐츠 크기만을 정의하고, 그 안에 추가되는 padding과 border는 크기에 포함되지 않습니다.

예를 들어, `width: 200px`로 설정된 요소에 `padding: 20px`과 `border: 2px solid black`이 있으면, 요소의 실제 너비는 `200px + 20px * 2 (padding) + 2px * 2 (border)`로, 총 `244px`가 됩니다. 이 방식은 padding과 border가 요소의 총 크기에 영향을 미친다는 점에서 때때로 예측하기 어려운 결과를 초래하기도 합니다.

### **2. `box-sizing: border-box`**

`border-box`를 적용하면 `width`와 `height` 값이 `내용 영역`, `padding`, `border`를 모두 포함하는 크기를 나타냅니다. 즉, `width`와 `height`는 실제 콘텐츠의 크기뿐만 아니라 패딩과 테두리까지 포함된 크기로 설정됩니다. 예를 들어, `width: 200px`로 설정된 요소에 `padding: 20px`과 `border: 2px solid black`이 있으면, 콘텐츠의 크기는 자동으로 `200px - 20px * 2 - 2px * 2`로 계산되어, 실제 콘텐츠 영역의 크기는 `156px`가 됩니다. 이 방식은 직관적으로 레이아웃의 크기를 예측하기 용이합니다.

</details>
<br/>

<details>
<summary> 위치를 동적으로 변경할 때 css 속성 중 transform과 position 중 어떤 것을 선호하시나요?</summary>
<br/>
`transform`과 `position`은 각각 적합한 경우가 다른데, 애니메이션이나 동적인 위치 변경이 필요한 경우 `transform`을 선호합니다.

`transform`을 선호하는 이유는 성능 때문입니다. `transform`은 브라우저의 composite 단계에서 실행됩니다. 따라서 reflow나 repaint를 유발하지 않아 성능 상 이점이 있습니다.

반면, `position` 관련 속성을 이용한 위치 변경은 reflow, repaint를 유발합니다. 예를 들어 `top`, `left` 등의 속성을 변경하면 브라우저는 주변 요소들의 위치를 다시 계산하는 과정부터 다시 수행하며, 이는 성능 부하를 높입니다.

두 방식을 사용하여 버튼 호버 시 살짝 위로 올라가는 효과를 구현하면 각각 다음과 같습니다.

```css
/* transform: 성능이 더 좋음 */
.button:hover {
  transform: translateY(-5px);
}

/* position: 성능이 상대적으로 떨어짐 */
.button {
  position: relative;
}
.button:hover {
  top: -5px;
}
```

## **그렇다면 position 관련 속성은 사용하지 않나요? 🤔**

아닙니다. 레이아웃의 구조를 잡거나, 부모를 기준으로 위치를 조정할 때에는 `position`을 사용합니다. `transform`은 시각적인 위치만 변경할 뿐 실제 문서 흐름과는 무관하게 동작하기 때문에, 문서 흐름에 따라 조정되는 경우에는 사용할 수 없기 때문입니다.

</details>
<br/>

<details>
<summary>👽 React CSS와 Normalize CSS가 무엇인가요?</summary>
<br/>
웹 개발에서는 브라우저가 제공하는 기본 스타일이 서로 다를 수 있기 때문에, 이를 통일하여 일관된 디자인을 구현하는 것이 중요합니다. **Reset CSS**와 **Normalize CSS**는 모두 **브라우저 간의 스타일 차이를 줄이기 위해 사용되는 CSS 파일**입니다. 두 방법은 목적이 같지만 방식에 차이가 있습니다.

먼저, **Reset CSS는 모든 브라우저의 기본 스타일을 완전히 제거하는 방식**입니다. 예를 들어, HTML 요소에 기본적으로 적용된 여백, 패딩, 글자 크기 등을 초기화하여, 모든 요소를 스타일이 전혀 없는 상태로 만듭니다. 이렇게 하면, 개발자는 특정 브라우저의 기본 스타일에 영향을 받지 않고 완전히 통제된 상태에서 스타일링을 시작할 수 있습니다. Reset CSS는 모든 요소를 초기화하기 때문에, 스타일을 처음부터 새롭게 작성해야 하는 수고가 있지만, 완전한 스타일 통일성을 보장합니다.

```css
/* 모든 요소의 기본 스타일을 초기화 */
* {
  margin: 0;
  padding: 0;
  border: 0;
  font-size: 100%;
  font: inherit;
  vertical-align: baseline;
}
```

반면, **Normalize CSS는 브라우저 간 스타일 차이를 줄이는 데 중점을 둔 방식**입니다. 모든 요소의 기본 스타일을 완전히 제거하는 대신, 브라우저 간에 일관되지 않은 스타일만 수정하여 자연스러운 기본값을 유지합니다. 예를 들어, Normalize CSS는 제목 태그(`h1`, `h2` 등)의 기본 크기나 폰트를 브라우저마다 일관되게 조정하면서도, 요소의 기본적인 스타일은 그대로 둡니다. 이를 통해 자연스러운 초기 스타일을 유지하면서, 브라우저 간의 주요한 차이만 해소하는 것입니다.

```css
/* 브라우저 기본 스타일을 일관되게 유지 */
h1 {
  font-size: 2em;
  margin: 0.67em 0;
}
a {
  background-color: transparent;
}
```

## **둘 중 어떤 방식을 선택하는 것이 좋나요? 🤔**

이는 **프로젝트 상황이나 개인의 취향에 따라 다를 수 있습니다**. 앞서 설명드렸던 것과 같이 **Reset CSS**는 스타일 통일성을 확실하게 보장받을 수 있다는 장점이 있지만, 처음부터 다시 스타일링해야 한다는 번거로움이 있습니다. 반면, **Normalize CSS**는 기본 스타일을 유지하는 장점이 있지만, 통일성이 비교적 떨어진다는 단점이 있습니다.

이러한 트레이드오프를 고려하여 결정해야 합니다. 예를 들어 데드라인이 넉넉하지 않은 프로젝트에서는 처음부터 일일이 스타일링할 여력이 없으니 **Normalize CSS**를 선택하는 것이 유리할 수 있습니다. 한편, 디자인 시스템과 같이 모든 것을 직접 스타일링하는 것이 중요한 상황에서는 **Reset CSS**를 선택하는 것이 유리할 수 있습니다.

</details>
<br/>
