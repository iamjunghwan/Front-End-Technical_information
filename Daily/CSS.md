<details>
<summary>🌹 CSS Flexbox와 Grid의 차이점에 대해서 설명해주세요.
 </summary>
<br/>
**Flexbox**와 **Grid**는 페이지에서 **레이아웃을 구성할 때 자주 사용되는 CSS 속성**입니다. 두 속성 모두 화면 요소를 배치하고 정렬하는 데에 사용되지만 몇가지 차이점이 존재합니다.

첫번째로 Flexbox는 **1차원 레이아웃이지만, Grid는 2차원 레이아웃**입니다.

**Flexbox**는 **1차원 레이아웃 속성**으로, row 또는 column 중 하나를 기준으로 요소를 정렬하고 배치하는 데 최적화되어 있습니다. 주로 행이나 열 중 하나의 방향으로 정렬해야 할 때 유용하며, 복잡한 행과 열을 모두 포함하는 레이아웃에서는 다소 한계가 있습니다.

반면 **Grid**는 **2차원 레이아웃 속성**으로, 행과 열을 모두 사용해 요소를 배치할 수 있습니다. 따라서 복잡한 레이아웃을 구성하거나, 웹페이지의 전체적인 구조를 잡는 데 적합합니다.

두번째는 **사용 목적의 차이**입니다.

**Flexbox**는 **콘텐츠 중심으로, 콘텐츠가 추가되거나 줄어들 때 유연하게 대처**하기 좋습니다. 예를 들어, 수평 또는 수직 방향으로 콘텐츠를 정렬하고 간격을 조절하는 데 유용하며, 버튼 그룹, 내비게이션 바 등 한 줄의 콘텐츠가 주가 되는 구성에 적합합니다.

**Grid**는 **레이아웃 중심으로 페이지 구조를 구성하는 데 최적화**되어 있습니다. 예를 들어, 카드 레이아웃, 갤러리 형식 등 명확하게 구분된 영역을 기반으로 레이아웃을 구성할 때 Grid가 효과적입니다.

마지막으로는 **기본 동작의 차이입니다**.

**Flexbox**에서는 주로 요소가 **컨테이너의 크기나 위치에 맞춰 자동으로 정렬**됩니다. Flexbox의 justify-content와 align-items 속성을 사용해, 주 축 방향으로 요소들을 배치하고 여백을 조절할 수 있습니다.

**Grid**는 **행과 열을 사전에 정의하고 그 격자(grid cell)에 요소를 배치하는 방식**입니다. Grid에서는 grid-template-rows, grid-template-columns와 같은 속성으로 행과 열의 크기를 정의하고, 각 요소의 위치를 세밀하게 설정할 수 있습니다.

</details>
<br/>

<details>
<summary>
😄 제로 런타임 css란 무엇인가요?
 </summary>
<br/>
**제로 런타임 CSS**는 CSS-in-JS의 단점을 보완하기 위해 등장한 방식입니다. 기존에 많이 쓰이던 CSS-in-JS 방식은 스타일을 컴포넌트 안에서 작성해서 동적으로 생성합니다. 이러한 방식은 런타임에서 CSS를 만들다 보니 성능 문제가 생길 가능성이 있습니다.

예를 들어, 사용자가 페이지를 로딩할 때마다 CSS를 동적으로 계산해서 DOM에 삽입하면, 브라우저가 이를 처리하는 데 시간이 걸리게 됩니다. 특히, 앱이 커질수록 성능이 떨어질 수 있고, CSS를 캐싱하기도 어려운 문제가 존재합니다. 그래서 나온 방식이 **빌드 시점에 CSS를 미리 다 만들어 놓는 제로 런타임 CSS 방식**입니다.

기존 CSS-in-JS 방식은 사용자가 앱을 실행할 때 CSS를 동적으로 생성했는데, 이 과정이 성능에 부담을 주는 경우가 있었습니다. 특히 렌더링이 복잡한 페이지에서 스타일 생성이 많아질수록 느려질 가능성이 큽니다. 동적으로 생성되는 CSS는 정적인 파일처럼 브라우저가 캐싱할 수 없어서, 매번 렌더링 될때마다 새롭게 계산해야 하기도 합니다. 또한 런타임에서 필요한 모든 스타일을 생성하려다 보니, 사용되지 않는 CSS 코드까지 포함되는 경우가 발생합니다.

반면에 제로 런타임 CSS는 앱이 실행되기 전에, 빌드 시점에 모든 스타일을 정적인 CSS 파일로 변환하는 방식입니다. 이렇게 된다면 런타임에 추가로 CSS를 생성하지 않으니 로딩 속도가 더 빠르고, 사용되지 않는 CSS는 빌드 과정에서 제거되기 때문에 최종 파일 크기가 작아집니다.

## **제로 런타임 CSS의 단점은 무엇이 있나요? 🤔**

런타임에서 **동적으로 생성해야 하는 스타일을 구현하기가 까다롭습니다**. 예를 들어, 사용자 입력값에 따라 스타일이 달라지는 경우엔 추가 로직을 작성해주어야 합니다. 또한 스타일을 빌드 시점에 모두 처리해야 하다 보니, 빌드 시간이 기존보다 길어질 수 있습니다.

</details>
<br/>

<details>
<summary>
🦿 길이 단위 px, em, rem에 대해 각각 설명해주세요.
 </summary>
<br/>
**px은 화면의 물리적인 픽셀 단위를 기준으로 한 고정 단위**입니다. 이 값은 절대적인 크기를 나타내며, 요소의 크기가 고정되어 디바이스의 해상도나 사용자 설정에 영향을 받지 않습니다. 예를 들어, `font-size: 16px`으로 설정하면 항상 16픽셀 크기로 표시됩니다. 픽셀 단위는 간단하고 정확한 제어를 제공하지만, 사용자의 접근성 설정(예: 브라우저에서 텍스트 크기 확대)에 따라 조정되지 않아 유연성이 떨어질 수 있습니다.

**em은 해당 요소에 현재 적용된(즉, 부모 요소 또는 현재 요소의) font-size를 기준으로 하는 상대 단위**입니다. 기본적으로, 브라우저의 초기 폰트 크기가 16px이므로, 상속받은 기본값이 없을 경우 1em은 16px로 계산됩니다. 그러나 상위 요소에 따라 상대적으로 크기가 결정되므로, 계층 구조가 깊어질수록 값이 누적되어 예기치 않은 크기로 설정될 수 있습니다. 예를 들어, 부모 요소가 `font-size: 20px`이고 자식 요소가 `font-size: 1.5em`으로 설정되면, 자식의 실제 폰트 크기는 30px이 됩니다.

**rem은 root em을 의미하며, 최상위 HTML 요소의 font-size를 기준으로 계산**됩니다. 이는 em과 달리 요소 계층에 따라 크기가 누적되지 않으며, 전역적인 기준을 따릅니다. 예를 들어, HTML의 font-size가 16px로 설정되어 있다면, 1rem은 항상 16px로 계산됩니다. 따라서 rem은 전역적으로 일관된 상대적인 크기를 설정할 때 유용하며, 접근성 측면에서도 사용자 설정에 잘 대응한다는 장점이 있습니다.

## **em과 rem이 모두 상대 단위라면, rem을 사용하지 않고 em을 사용해야 하는 경우는 언제인가요? 🤔**

rem을 항상 사용하지 않고 em을 사용하는 경우는 **특정 상황에서 해당 컨텍스트에 따라 상대적인 크기를 지정해야 하는 경우**입니다. em은 부모 요소 또는 현재 요소의 font-size를 기준으로 크기가 결정되므로, 구성 요소 간의 비례적인 크기를 쉽게 조정할 수 있습니다. 예를 들어, 버튼 안의 텍스트와 패딩을 비율로 정의하고 싶을 때, 각각의 속성에 em을 사용하면 텍스트 크기를 조정될 때 패딩이 자연스럽게 비례적으로 조정되도록 할 수 있습니다.

반면, rem은 루트 요소를 기준으로 고정된 상대 크기를 제공하기 때문에 전역적인 일관성에는 적합하지만, 특정 컨텍스트에 맞춘 비례 조정이 필요한 경우에는 부적합할 수 있습니다.

</details>
<br/>
