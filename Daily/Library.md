<details>
<summary>🚗 tanstack-query에서 stale time과 gc time의 차이점에 대해서 설명해주세요 </summary>
<br/>
TanStack Query에서 `stale time`과 `gc time`은 데이터를 캐싱하고 관리하는 데 중요한 두 가지 설정입니다. 먼저 요약해서 말씀 드려보자면, `stale time`은 **데이터가 얼마나 오래 '신선한 상태'로 유지되는지**를 정하는 시간이고, `gc time`은 **데이터가 오래된 상태가 된 이후에도 캐시에서 얼마 동안 유지될지**를 정하는 시간입니다.

먼저, `stale time`은 데이터를 처음 가져온 후에 그 **데이터를 '신선한' 상태로 간주하는 시간**을 말합니다. 이 기간 동안에는 같은 데이터에 대한 추가적인 네트워크 요청이 일어나지 않고, 캐시에 저장된 데이터를 그대로 사용하게 됩니다. 예를 들어, `stale time`을 5분으로 설정하면, 데이터를 가져오고 나서 5분 동안은 이 데이터가 '신선하다'고 판단해서 네트워크 요청 없이 캐시된 데이터를 계속 사용합니다. `stale time`의 기본값은 0입니다.

반면에 gc time은 **데이터가 '오래된' 상태가 된 이후에도 캐시에 얼마 동안 남아 있을지를 정하는 시간**입니다. stale time이 지나면 데이터는 '오래된' 상태가 되지만, gc time이 설정되어 있으면 지정된 시간 동안 여전히 캐시에서 그 데이터를 유지하게 됩니다. 예를 들어, gc time을 10분으로 설정하면, 데이터가 stale 상태가 된 이후 10분 동안 캐시에 남아 있다가 자동으로 삭제됩니다. tanstack-query에서 설정한 기본 gc time은 5분입니다.

정리해서 말씀드려보자면, `stale time`은 **데이터를 처음 가져온 후 얼마 동안 네트워크 요청 없이 캐시된 데이터를 사용할지**를 정하는 시간이고, `gc time`은 그 **데이터가 오래된 상태가 된 후에도 캐시에 유지될** 시간을 정하는 겁니다. 이렇게 각각의 설정을 통해 데이터를 더 효율적으로 관리하고, 불필요한 네트워크 요청을 줄이면서도 최신 데이터를 가져올 수 있도록 합니다.

</details>
<br/>

<details>
<summary>🫧 리액트의 props와 state에 대해서 설명해주세요.</summary>
<br/>
`props`는 부모 컴포넌트가 자식 컴포넌트에 전달하는 데이터입니다. props는 읽기 전용으로, 자식 컴포넌트는 props를 수정할 수 없습니다.

```tsx
function ChildComponent(props) {
  props.name = "New Name"; // 오류 발생 가능
  return <div>{props.name}</div>;
}
```

이를 통해 컴포넌트 간의 데이터 흐름을 예측 가능하게 만들고, 컴포넌트의 재사용성을 높입니다.

`state`는 컴포넌트 내부에서 관리되는 데이터입니다. state는 동적으로 변경될 수 있으며, 컴포넌트의 렌더링에 영향을 미칩니다. state를 변경하면 컴포넌트는 다시 렌더링되며, UI가 업데이트됩니다. state는 주로 사용자 입력이나 네트워크 요청의 응답에 따라 변하는 데이터를 관리할 때 사용됩니다.

## **props가 자식 컴포넌트에서 변하지 않는 이유는 무엇인가요?**

props가 자식 컴포넌트에서 변하지 않는 이유는 리액트의 **단방향 데이터 흐름 원칙** 때문입니다. 리액트는 부모 컴포넌트가 자식 컴포넌트에 데이터를 전달할 때 단방향으로 전달하도록 설계되었습니다. 이렇게 하면 컴포넌트 간의 데이터 흐름을 예측 가능하고 일관성 있게 만들 수 있어 애플리케이션 상태 관리가 간단해집니다.

props는 **읽기 전용**이기 때문에, 부모 컴포넌트에서 전달된 값이 자식 컴포넌트 내에서 임의로 변경되지 않습니다. 이로 인해, 특정 상태가 어디서 어떻게 변했는지를 예측할 수 있어 버그 발생 가능성을 줄이고 디버깅을 쉽게 합니다.

만약 props가 변경될 수 있다면, 자식 컴포넌트는 독립적으로 동작하지 않게 되고, 재사용이 어려워질 수 있습니다. props가 불변으로 유지됨으로써 컴포넌트는 외부 입력에 의존할 뿐 내부적으로 변경하지 않아 재사용성이 높아지고, 코드의 캡슐화가 강화됩니다.

## **만약 자식 컴포넌트에서 부모 컴포넌트로부터 받은 props를 변경해야한다면 어떻게 해야할까요?**

만약 자식 컴포넌트가 부모로부터 받은 데이터를 수정해야 한다면, 상태를 부모 컴포넌트로 올려 부모 컴포넌트에서 props를 다시 전달하는 방식으로 구현해야 합니다. 이렇게 하면 데이터는 여전히 단방향으로 흐르고, 상태는 부모 컴포넌트가 관리해 일관성을 유지할 수 있습니다. 이러한 기법을 **상태 끌어올리기**라고 합니다.

</details>
<br/>

<details>
<summary>🚧 리액트의 Controlled Component와 Uncontrolled Component의 차이점에 대해서 설명해주세요. </summary>
<br/>
`Controlled Component`는 리액트 상태(state)를 통해 입력값을 제어하는 컴포넌트를 말합니다. 이 방식에서는 입력 요소의 값(value)을 리액트 상태와 동기화하고, 사용자가 입력을 변경할 때마다 onChange 이벤트 핸들러를 통해 상태를 업데이트합니다. useState를 활용한 input value를 제어하는 상황을 예시로 들 수 있습니다. value는 리액트 상태로 관리되며, onChange 이벤트가 발생할 때마다 상태가 업데이트됩니다. **Controlled Component의 주요 장점은 입력값이 리액트의 상태로 관리되므로, 입력값을 쉽게 검증하고, 변경할 수 있으며, 복잡한 폼 로직을 처리하는 데 유리**하다는 것입니다.

`Uncontrolled Component`는 리액트의 상태가 아닌, DOM 자체가 입력값을 제어하는 방식입니다. 즉, 입력 요소의 값은 DOM에서 직접 관리되며, 리액트는 이를 제어하지 않습니다. 이 방식에서는 `ref`를 사용하여 DOM 요소에 직접 접근해 값을 읽어오거나 조작할 수 있습니다.

input과 관련 된 ref는 useRef를 사용해 생성된 참조 객체로, 입력값을 직접 접근하고 조작할 수 있습니다. **Uncontrolled Component는 상대적으로 간단한 폼이나 초기값이 중요한 상황**에서 사용할 수 있습니다.

## **Controlled Component와 Uncontrolled Component를 통해 상태를 관리하는 것 중 어느 상황에 어떤 방법을 선택해야 하나요?**

ref를 사용하면 DOM을 통해 직접 접근하여 값을 읽어오기때문에, 단순한 입력 필드가 포함된 폼에서 ref를 사용하는 것이 더 간단하고 성능이 좋을 수 있습니다. 사용자가 제출 버튼을 클릭했을 때만 입력값을 가져오면 되는 경우를 예로 들 수 있습니다.

만약에 값을 입력할때마다 유효성 검증을 실시간을 해주어야하는 경우에는 Controlled Component를 사용하는 것이 좋습니다.

</details>
<br/>

<details>
<summary>🚑 리액트에서 성능 최적화를 위한 방법들을 설명해주세요. </summary>
<br/>
리액트에서 성능 최적화를 위해 여러 가지 방법을 사용할 수 있는데요. 대표적으로 메모이제이션을 말씀 드릴 수 있겠습니다.

리액트의 `memo`를 사용하여 컴포넌트를 메모이제이션할 수 있습니다. 이는 컴포넌트의 props가 변경되지 않았을 때, 리렌더링을 방지하여 성능을 최적화합니다. 이는 특히 렌더링 비용이 큰 컴포넌트에서 유용합니다.

또한 `useCallback`과 `useMemo`를 활용할 수도 있습니다. `useCallback` 은 함수를 메모이제이션하여 불필요한 함수 재생성을 방지하고, `useMemo`는 값의 재계산을 방지하여 성능을 최적화합니다. 이를 통해 자식 컴포넌트로 전달되는 함수나 값이 변경되지 않으면 리렌더링을 피할 수 있습니다.

마지막으로 `코드 스플리팅`을 활용해볼 수 있습니다. 코드 스플리팅은 큰 애플리케이션을 여러 개의 작은 청크로 나누어, 필요한 청크만 로드하게 하여 초기 로드 시간을 줄입니다. React.lazy와 Suspense를 사용하여 동적으로 컴포넌트를 로드할 수 있습니다.

## **그럼 코드 스플리팅은 어떤 경우에 사용해야할까요?**

첫번째로는 **초기 로딩 시간이 길어지는 경우**입니다. 애플리케이션이 커지면, 초기 로딩에 모든 코드를 로드하는 것이 비효율적일 수 있습니다. 코드 스플리팅을 사용해 초기 로드 시 필요한 핵심 코드만 로드하고, 이후 추가적인 기능은 필요할 때 로드하도록 하면 초기 로딩 속도를 크게 개선할 수 있습니다.

두번째로는 **라우트별 코드 분할이 필요한 경우**입니다. SPA에서는 각 페이지가 별도의 기능과 UI를 가지므로, 라우트별로 필요한 코드만 분리하여 로드할 수 있습니다. 이 방식은 리액트의 React.lazy와 Suspense를 사용하여 라우트별 컴포넌트를 동적으로 불러올 때 유용합니다.

</details>
<br/>

<details>
<summary>💥 리액트의 Strict Mode에 대해서 설명해주세요. </summary>
<br/>
리액트에서 `StrictMode`는 주로 개발 중에 발생할 수 있는 잠재적인 문제를 사전에 감지하고 예방하기 위해 사용됩니다. 몇 가지 주요 목적이 있습니다.

첫째로 오래된 라이프사이클 메서드와 비권장 API의 사용을 감지합니다. 예를 들어, `componentWillMount`, `componentWillReceiveProps`와 같은 메서드는 더 이상 사용이 권장되지 않는데, StrictMode는 이러한 메서드들이 코드에 포함된 경우 경고를 표시해줍니다. 이를 통해 개발자가 최신 React API를 사용하여 보다 안정적이고 효율적인 코드를 작성하도록 돕습니다.

둘째, **의도치 않은 부수 효과를 방지**합니다. 리액트는 컴포넌트의 렌더링이 예측 가능하고 순수하게 이루어지기를 기대합니다. StrictMode는 이를 검증하기 위해 useEffect, useState 등 일부 훅이나 메서드를 두 번씩 실행합니다. 이렇게 두 번 실행되는 이유는, 동일한 결과가 나오는지 확인함으로써 컴포넌트가 사이드 이펙트를 일으키지 않고 순수하게 동작하는지를 검사하기 위함입니다.

이러한 검증이 중요한 이유는 예기치 않은 동작이나 버그를 사전에 방지하기 위해서입니다. 개발 환경에서 두 번씩 실행해봤을 때 문제가 발생하지 않으면, 프로덕션에서도 안전하게 실행된다는 신호라고 볼 수 있습니다. 이 과정에서 부수 효과가 감지되면 개발자는 코드를 수정해야 할 필요가 있습니다.

다만, 이러한 두 번 실행되는 현상은 개발 모드에서만 발생하고, 실제 프로덕션 빌드에서는 정상적으로 한 번만 실행되기 때문에 성능에 영향을 미치지 않습니다.

이렇게 StrictMode는 개발자가 더욱 안전하고 효율적인 코드를 작성할 수 있도록 도와주는 도구라고 말씀드릴 수 있습니다.

</details>
<br/>

<details>
<summary>🐣 리액트의 render phase와 commit phase에 대해서 설명해주세요. </summary>
<br/>
리액트의 렌더링 과정은 크게 두 가지 단계로 나눌 수 있습니다. `render phase`와 `commit phase`입니다.

먼저 `render phase`는 리액트가 변화된 상태나 props에 따라 어떤 **UI가 변경되어야 할지를 결정하는 단계**입니다. 이 과정에서는 실제로 DOM을 업데이트하지 않고, 변경사항을 가상 DOM에서 계산하여 비교합니다. 이 단계는 순수하게 계산과정이기 때문에 성능에 영향을 주지 않도록 중단되거나 다시 실행될 수 있으며, React 18에서 도입된 Concurrent Mode를 통해 비동기적으로 처리될 수도 있습니다.

다음으로 commit phase는 실제로 변화된 **UI를 DOM에 반영하는 단계**입니다. 이때 리액트는 가상 DOM에서 계산된 결과를 실제 DOM에 적용하고, 변화된 UI를 브라우저에 렌더링합니다. 이 과정에서는 useEffect와 같은 사이드 이펙트가 발생하는 훅들이 실행됩니다.

요약해서 말씀드려보자면 render phase는 변화된 UI를 결정하는 과정이고, commit phase는 그 결정된 결과를 실제로 반영하는 단계입니다.

## **그럼 render phase와 commit phase는 어떻게 동기화되나요?**

두가지의 단계로 말씀드릴 수 있습니다. **단계적 진행**과 **병목 관리**입니다. 첫번째로 render phase가 완료되면 리액트는 즉시 commit phase를 실행하지 않고, 다른 높은 우선순위 작업이 있다면 먼저 처리한 후 나중에 commit phase를 실행할 수 있습니다. 이를 통해 React는 동기화가 필요한 작업을 효율적으로 관리하여 사용자 경험을 개선합니다.

두번째로 **병목 관리**입니다. render phase에서 모든 변경 사항이 Fiber Tree에 준비된 상태에서 commit phase로 넘어가므로, render와 commit 단계의 일관성이 유지됩니다. 이렇게 두 단계는 순차적으로 작동하여, UI가 정확하게 동기화되고 불필요한 재렌더링을 방지합니다.

</details>
<br/>

<details>
<summary>⚒️ 리액트에서 index를 key값으로 사용하면 안되는 이유에 대해서 설명해주세요.
 </summary>
<br/>
리액트에서 index를 key로 사용하는 것은 권장되지 않는 이유는 배열의 요소들이 추가되거나 삭제될 때, 배열의 순서가 바뀌는 경우 문제가 발생할 수 있기 때문입니다.

리액트는 key를 통해 리스트에서 어떤 요소가 변경, 추가, 삭제되었는지를 추적합니다. 그러나 index를 key로 사용하면 배열의 순서가 변경될 때 리액트가 요소들을 잘못 인식할 수 있습니다. 예를 들어, 배열에 새로운 요소가 추가되면 그 뒤에 있는 요소들의 인덱스가 모두 바뀌게 됩니다. 리액트는 이를 새로운 요소로 인식해 불필요하게 재렌더링을 하거나, 요소의 상태를 잘못 처리할 수 있습니다.

이로 인해 성능 문제가 발생하거나, 사용자 입력 상태 같은 요소가 의도치 않게 초기화되는 등 예기치 않은 버그가 생길 수 있습니다. 그래서 배열의 순서나 요소 변경에 영향을 받지 않는 고유한 값을 key로 사용하는 것이 좋습니다.

## **key로 사용되는 고유한 값의 생성 방법에는 어떤 것들이 있나요?**

key로 사용할 고유한 값을 생성하는 방법에는 여러 가지가 있습니다. 주로 데이터의 유일성을 보장하고 변하지 않는 값을 사용하는 것이 중요합니다.

이러한 경우 주로 서버의 데이터베이스에서 제공하는 고유 ID를 사용하는 것이 일반적입니다. 또한 `UUID` 같이 전역적으로 고유한 id를 생성이 가능한 라이브러리를 사용해볼 수도 있습니다.

</details>
<br/>

<details>
<summary>👀 useEffect와 useLayoutEffect의 차이점에 대해서 설명해주세요.
 </summary>
<br/>
`useEffect`와 `useLayoutEffect`는 모두 렌더링된 후에 특정 작업을 수행하기 위해 사용됩니다. 하지만 실행되는 **타이밍**과 **용도**가 다릅니다.

먼저, `useEffect`는 **렌더링이 완료되는 시점**에 **비동기적**으로 실행됩니다. 즉, 화면이 실제로 사용자에게 그려진 후에 `useEffect`가 실행되는 방식입니다. 그래서 `useEffect`는 보통 데이터를 가져오는 작업이나 이벤트 리스너 추가 등 렌더링 후에 화면에 직접적인 영향을 주지 않는 작업에 주로 사용됩니다.

반면에 `useLayoutEffect`는 **렌더링 후 DOM이 업데이트되기 직전의 시점**에 **동기적**으로 실행됩니다. 여기서 **동기적**이라는 것은 화면에 내용이 그려지기 전에 모든 레이아웃 관련 작업이 완료된다는 의미입니다. 예를 들어, **DOM의 크기를 측정**하거나 **위치를 조정해야 할** 때 `useLayoutEffect`를 사용하면 즉각적으로 그 변경사항이 반영되어 화면 깜빡임이나 불필요한 재렌더링을 방지할 수 있습니다.

정리하면, **렌더링 후 실행되는 비동기 작업**에는 `useEffect`가 적합하고, 레이아웃 작업이나 DOM 조작과 같이 **화면이 그려지기 전에 완료되어야 하는 작업**에는 `useLayoutEffect`가 적합합니다.

예를 들면, `useEffect`는 사용자 데이터를 API로부터 가져오는 상황에 자주 사용합니다. 데이터가 렌더링 후에 설정되면 화면이 자연스럽게 업데이트되는 것입니다.

```jsx
useEffect(() => {
  fetchData().then((data) => setData(data));
}, []);
```

`useLayoutEffect`는 DOM의 크기를 측정해서, 다른 요소의 위치를 조정해야 할 때 유용합니다. 예를 들어, 어떤 요소의 높이를 측정해 그 높이에 맞춰 레이아웃을 맞추고 싶을 때 사용합니다:

```jsx
useLayoutEffect(() => {
  const height = ref.current.offsetHeight;
  setHeight(height);
}, []);
```

단, `useLayoutEffect` 사용 시 **성능 면에서 주의할 점**이 있습니다. `useLayoutEffect`는 동기적으로 실행되기 때문에 너무 많은 작업이 실행되면 렌더링이 느려질 수 있습니다. 따라서 보통은 `useEffect`를 기본적으로 사용하고, 화면에 영향을 주는 작업만 `useLayoutEffect`로 처리하는 것이 좋습니다.

</details>
<br/>

<details>
<summary>🤪 React에서 Error Boundary가 무엇이며, 이를 사용해야 하는 이유는 무엇인가요?
 </summary>
<br/>
### **Error Boundary란?**

**Error Boundary**는 React **컴포넌트에서 발생하는 오류를 잡아내고, 전체 애플리케이션이 다운되는 것을 방지하기 위한 특수한 컴포넌트**입니다. 일반적으로 클라이언트에서 오류가 발생할 때 표시할 UI를 제공하여, 애플리케이션의 신뢰성과 사용자 경험을 높이는 데 활용됩니다. 클래스형 컴포넌트의 `componentDidCatch`와 `getDerivedStateFromError` 두 가지 라이프사이클 메서드를 사용하여 오류 발생 시의 행동을 정의할 수 있습니다. Error Boundary는 **클래스형 컴포넌트에서만 사용**할 수 있습니다.

### **Error Boundary가 필요한 이유**

React는 기본적으로 비동기 작업에서 발생하는 오류를 자동으로 처리하지 않으므로, 오류가 발생할 경우 페이지 전체가 하얗게 변하거나 사용자 입장에서 알 수 없는 화면이 표시되는 상황이 발생할 수 있습니다. 이는 사용자 경험을 크게 저해하고, 특히 대규모 애플리케이션에서 신뢰성에 큰 문제가 됩니다. **Error Boundary**는 이러한 문제를 해결하여 **에러가 발생한 영역에서 대체 UI를 표시하고, 애플리케이션의 나머지 부분은 정상적으로 동작하도록** 도와줍니다. Error Boundary를 적절히 배치하면, 오류가 발생한 컴포넌트만 대체 UI로 전환되어 애플리케이션의 안정성을 유지하고, 사용자에게 오류 메시지나 대체 화면을 제공하여 더 나은 사용자 경험을 제공합니다. 더불어 Error Boundary는 오류 발생 시의 대체 UI 로직을 **선언형으로** 작성할 수 있게 하여 코드의 가독성과 유지 보수성을 높이는 데 도움이 됩니다.

## **선언형으로 처리한다는 게 무슨 의미이며, 그게 왜 유지 보수성에 도움이 되나요?**

선언형으로 처리한다는 의미는, **개발자가 “무엇을 해야 하는지”를 정의하는 방식**으로, “어떻게 할지”에 대한 세부적인 절차를 직접 작성하지 않아도 된다는 것을 뜻합니다. 예를 들어, Error Boundary에서 “이 컴포넌트가 오류를 감지하면 특정 대체 UI를 보여준다”와 같은 목적을 코드 상에서 명시함으로써, 실제로 오류가 발생할 때 실행되는 세부적인 절차는 컴포넌트가 알아서 처리하게 됩니다.

유지 보수성에 도움이 되는 이유는, **선언형 코드가 명령형 코드에 비해 직관적이고 간결하여 가독성이 높기 때문**입니다. Error Boundary를 예로 들면, 특정 Error Boundary로 감싼 영역이 어떤 방식으로 에러를 처리할지 한 눈에 알 수 있습니다. 또한, 비즈니스 로직과 에러 처리 로직이 명확하게 분리되어 코드의 복잡성이 낮아집니다.

</details>
<br/>

<details>
<summary>☺️ 리액트 동시성 모드(Concurrent Mode)에 관해서 설명해주세요.
 </summary>
<br/>
리액트의 **동시성 모드**는 여러 작업을 **비동기적으로 동시에 처리하면서도 중간에 더 중요한 작업이 들어오면 우선순위를 바꿔서 그 작업을 먼저 처리하는 기능**을 의미합니다. 예전 리액트는 스택 구조로 이루어졌습니다. 즉 한 번 렌더링을 시작하면 끝까지 멈추지 않고 다 처리해야 했습니다. 하지만 동시성 모드에서는 중간에 멈추거나 작업을 잠시 뒤로 미뤄둘 수 있어서 중요한 작업을 먼저 끝낼 수 있게 되었습니다.

이 동시성을 활용하여 리액트는 중요한 작업과 덜 중요한 작업을 나눠서, 덜 중요한 작업은 백그라운드에서 진행하고 중요한 부분은 바로 사용자에게 보여줍니다. 예를 들어 검색창에 뭔가를 입력하고 있을 때, 그에 맞춰 검색 결과가 업데이트되더라도, 리액트가 해당 작업을 백그라운드에서 처리하게 해서 화면이 느려지지 않게 할 수 있습니다.

## **동시성을 활용한 기능에는 무엇이 있나요?**

첫번째로 `startTransition`이란 기능을 이용하면 특정 상태 업데이트를 “덜 중요한 작업”으로 분류해서, 사용자가 클릭하거나 입력하는 반응 같은 중요한 업데이트가 우선적으로 처리 됩니다. 또 `useDeferredValue`라는 훅을 사용하면 값의 업데이트를 잠깐 지연시킬 수 있어서, 사용자가 뭔가 빠르게 입력할 때마다 리렌더링되지 않게 최적화할 수 있습니다.

동시성 모드의 장점은 사용자와 상호작용하는 부분이 훨씬 매끄럽게 느껴진다는 것입니다. 예를 들어, 사용자가 스크롤할 때 다른 무거운 작업이 있다 하더라도, 동시성 모드 덕분에 스크롤이 우선적으로 부드럽게 작동하게 만들 수 있습니다.

## **동시성 기능을 활용할때 주의할 점은 없을까요?**

주의할 점은 모든 컴포넌트에 이 동시성 모드를 무분별하게 적용하면 오히려 성능이 떨어질 수 있다는 점입니다. 그래서 필요한 부분에만 이 동시성 모드를 잘 활용하는 것이 중요하다고 볼 수 있습니다.

## **그럼 동시성이 필요한 부분은 언제인가요?**

동시성이 필요한 상황은 주로 **사용자와의 상호작용이 빈번하고 응답성이 중요한 경우**입니다.

첫 번째 예로, **검색 필터링**이나 **자동 완성** 같은 기능이 있습니다. 사용자가 검색어를 입력할 때마다 결과가 업데이트되는 경우, 모든 입력마다 화면이 리렌더링된다면 앱이 느려지고 입력할 때마다 끊김을 느낄 수 있습니다. 이때 동시성 모드를 사용하면 검색어 입력 자체가 더 중요한 작업이 되어 검색 결과 업데이트는 백그라운드에서 처리되므로, 입력이 빠르고 부드럽게 유지됩니다.

두 번째로, **무거운 데이터나 리스트를 로딩하는 경우**에 유용합니다. 예를 들어 긴 스크롤 목록을 보면서 네트워크를 통해 데이터를 로딩할 때, 새로운 항목을 추가로 불러오는 작업보다 사용자가 현재 보고 있는 화면의 스크롤이 더 중요한 작업입니다. 이때 동시성을 사용하면 로딩은 백그라운드로 넘기고, 스크롤을 최우선으로 부드럽게 렌더링할 수 있습니다.

또한, **애니메이션이 포함된 화면 전환이나 중요도가 높은 사용자 입력 작업**도 동시성을 고려할 만한 케이스입니다. 사용자가 버튼을 클릭했을 때 UI가 즉각적으로 반응하고, 이후에 비동기 작업이 처리되도록 설정해 주면 클릭 시의 지연 없이 상호작용이 자연스러워집니다.

</details>
<br/>

<details>
<summary>
🫢 useEffect를 이용하여 로딩 상태 관리하는 방법과 Suspense를 활용하는 방법에 대한 차이점을 설명해주세요.
 </summary>
<br/>
`Suspense`와 기존 로딩 상태 관리 방식인 `useEffect`와 loading state는 로딩 상태를 관리하는 방식에서 근본적인 차이가 있습니다. 기존 방식에서는 데이터를 불러올 때 useEffect 훅을 사용하고, 로딩 상태를 관리하기 위해 loading이라는 별도의 상태 변수를 만들어야 합니다. 예를 들어, 데이터를 불러오는 동안엔 loading을 true로 설정하고, 데이터가 다 불러온다면 false로 바꾸는 식입니다. 그래서 조건에 따라 로딩 UI를 보여주는 식으로 작동합니다. 이 방식은 간단한 상황에서는 충분히 유효하지만, 여러 개의 비동기 데이터를 다룰 때에는 조건부 렌더링 로직이 복잡해질 수 있습니다.

반면, `Suspense`는 로딩 중인 컴포넌트를 직접 렌더링하지 않고, `Suspense` 컴포넌트의 fallback 속성으로 로딩 UI를 정의하게끔 합니다. 데이터를 기다리는 동안에는 fallback으로 정의된 UI만 보여주고, 데이터가 모두 준비되면 Suspense에 감싸진 컴포넌트를 자연스럽게 표시합니다. 이렇게 로딩 상태를 선언적으로 관리할 수 있기 때문에, 전체적인 코드가 단순해지고 유지보수도 쉬워집니다.

## **Suspense의 단점은 무엇일까요?**

여러 개의 Suspense 컴포넌트를 중첩하거나 트리 구조로 사용할 경우, 각 Suspense가 독립적으로 로딩 상태를 관리하기 때문에 데이터 준비 시점이 다를 수 있습니다. 그 결과 로딩 화면(fallback)이 여러 번 표시되거나 비일관적인 UI 경험이 발생할 수 있습니다. 이를 적절히 제어하기 위해서는 트리의 구조와 데이터 로딩 흐름을 신중하게 설계해야 합니다.

또한 Suspense는 Promise 기반의 비동기 작업만 지원합니다. 따라서 일반적인 fetch 요청에 바로 적용할 수 있는 것이 아니라, 이를 위해 추가적인 라이브러리를 사용하거나 Suspense와 호환되는 형태로 Promise를 관리해야 합니다.

</details>
<br/>

<details>
<summary>
🥸 Tanstack Query를 사용하는 이유를 설명해 주세요.
 </summary>
<br/>
**TanStack Query**는 **서버 상태 관리의 복잡성을 극복하기 위해** 사용하는 라이브러리입니다. 여기서 **서버 상태**란 **서버에서 제공하는 데이터**로, 클라이언트에서 직접 수정할 수 없고 네트워크 요청과 같은 비동기 작업을 통해 가져오거나 갱신해야 하는 데이터를 의미합니다.

TanStack Query를 사용하는 주요 이유는 다음과 같습니다.

첫째, **효율적인 캐싱 처리 기능**을 제공합니다. 이를 통해 동일한 데이터를 반복적으로 요청하지 않아 네트워크 비용을 절감하고, 캐싱된 데이터를 즉시 제공해 더 나은 사용자 경험을 제공할 수 있습니다.

둘째, **비동기 데이터 관리의 복잡성을 줄여줍니다**. TanStack Query는 데이터의 가져오기(fetch), 갱신(refetch), 무효화(invalidate) 등의 작업을 선언적으로 처리할 수 있어 코드가 간결해지고 유지보수가 용이해집니다.

셋째, **에러 및 로딩 상태 관리를 단순화**합니다. `useQuery`와 `useMutation` 훅을 사용하면 서버 데이터와 관련된 로딩, 성공, 실패 상태를 명확하고 직관적으로 처리할 수 있어 로직이 깔끔해집니다.

이처럼 TanStack Query는 서버 상태 관리에서 발생하는 복잡한 문제를 해결하고 개발자가 비즈니스 로직에 더 집중할 수 있도록 도와줍니다.

## **TanStack Query를 사용할 때 발생할 수 있는 단점이나 한계는 무엇인가요?**

TanStack Query는 서버 상태 관리를 간편하게 해주지만, 사용 시 몇 가지 단점 및 한계가 있습니다.

첫째, **캐싱 전략 관리의 복잡성**입니다. TanStack Query는 강력한 캐싱 기능을 제공하지만, `staleTime`, `gcTime` 같은 옵션을 잘못 설정하면, 데이터 갱신 타이밍이 적절하지 않아 최신 데이터가 사용자에게 노출되지 않거나 불필요한 요청이 발생할 수 있습니다.

둘째, **초기 학습 곡선이 존재**합니다. Query Key 설계, 데이터 무효화 등 다양한 개념을 이해하고 적절히 활용해야 하므로 초기에 학습해야 하는 지식의 양이 많습니다.

마지막으로, **클라이언트 상태와 서버 상태 간 의존 관계가 복잡한 경우**, TanStack Query만으로는 해결하기 어려울 수 있습니다. 이때는 Redux, Zustand 등 별도의 상태 관리 라이브러리가 필요할 수 있습니다.

</details>
<br/>

<details>
<summary>
🎭 리액트에서 컴포넌트란 무엇인가요?
 </summary>
<br/>
리액트에서 **컴포넌트는 UI를 구성하는 독립적이고 재사용 가능한 코드 조각**이라고 설명드릴 수 있습니다. 컴포넌트는 특정 기능이나 UI 요소를 캡슐화합니다. 잘 만들어진 컴포넌트는 주로 단일 책임 원칙을 따릅니다.

리액트 내에서 컴포넌트는 크게 **클래스형**과 **함수형**으로 나눌 수 있는데, 최근에는 Hooks의 도입으로 함수형 컴포넌트가 주로 사용되고 있습니다. 함수형 컴포넌트는 더 간결하고 이해하기 쉬운 코드를 작성할 수 있게 해줍니다.

컴포넌트의 주요 장점은 **재사용성**과 **유지보수성**입니다. 예를 들어, 버튼 컴포넌트를 한 번 만들면 여러 페이지에서 다양한 스타일과 기능으로 재사용할 수 있습니다. 또한 컴포넌트는 props를 통해 부모로부터 데이터를 전달받을 수 있어, 동적인 UI를 손쉽게 구현할 수 있습니다.

## **컴포넌트 설계 시 중요하게 고려해야 하는 사항에는 어떤 것들이 있나요?**

React 컴포넌트 설계 시에는 다음과 같은 사항들을 고려해야 합니다.

첫째, **하나의 컴포넌트가 너무 많은 책임을 갖지 않도록 해야 합니다.** 컴포넌트의 역할이 명확하도록 설계해야 합니다. 물론, 이를 고려하지 않아도 정상 작동은 하겠지만, 추후의 유지보수성을 고려해야 하는 상황이라면 하나의 컴포넌트가 너무 많은 책임을 가지지 않도록 하는 것이 중요합니다. 대표적인 예시로, 비즈니스 로직과 UI 로직을 철저히 분리하는 것을 들 수 있습니다.

둘째, **재사용성을 고려**해야 합니다. 만약 특정 컴포넌트가 여러 상황에서 재사용될 가능성이 높다면 유연하게 설계해야 추후 재사용이 용이합니다. props를 통해 필요한 데이터와 동작을 주입받아 다양한 상황에서 쉽게 재사용될 수 있도록 하는 것이 좋습니다. 이를 '컴포넌트가 춤을 춘다'고 비유적으로 표현하기도 합니다.

셋째, **성능 최적화**를 고려해야 합니다. 불필요한 리렌더링을 방지하기 위해 메모이제이션을 적절히 활용하고, 컴포넌트의 크기를 적절히 유지해야 하는 것이 좋습니다.

사실, 이밖에도 고려해야 할 상황이 정말 많으며, 앞서 말씀드린 사항들이 모든 상황에 똑같이 적용되는 것도 아닙니다. 가장 중요한 것은, **각각의 상황에 맞는 컴포넌트를 만드는 것**이라고 생각합니다. 유지보수성, 성능, 재사용성 등이 어떠한 상황에서는 중요할 수도, 어떠한 상황에서는 중요하지 않을 수도 있습니다. 이를 적절하게 판단하여 **당장의 상황에 부합하는 최적의 컴포넌트**를 만들어 내기 위해 고민하는 태도가 중요합니다.

</details>
<br/>

<details>
<summary>💅 전역 상태 관리 라이브러리는 왜 사용하나요?
 </summary>
<br/>
전역 상태 관리 라이브러리를 사용하는 이유에 대해 크게 세 가지를 설명드리겠습니다.

첫째, **컴포넌트 간 상태 공유가 용이해집니다**. 여러 컴포넌트에서 공통적으로 사용되는 상태를 중앙화하여 관리하고, 여러 곳에서 쉽게 접근할 수 있습니다. 부모 컴포넌트에서 자식 컴포넌트에게 상태를 전달하기 위해 여러 컴포넌트를 거치는 "props drilling"을 겪지 않고 상태를 공유할 수 있습니다.

둘째, **관심사 분리가 용이해집니다**. 상태 관리 로직을 컴포넌트에서 분리하여 별도로 관리함으로써, 컴포넌트는 UI 로직에만 집중할 수 있게 됩니다. 예를 들어 Redux에서는 상태 변경 로직을 Reducer에 정의해두고, 컴포넌트 단에서는 Dispatch를 통해 Reducer를 호출하는 방식으로 동작합니다. 이러한 분리는 "관심사의 분리 원칙"을 따르며 코드 재사용성과 테스트 용이성을 높여줍니다.

셋째, **성능 최적화에 도움이 됩니다**. 현대의 상태 관리 라이브러리들은 불필요한 리렌더링을 방지하는 메커니즘을 제공합니다. 예를 들어 Zustand는 구독 메커니즘을 통해 실제로 상태가 변경된 컴포넌트만 리렌더링되도록 보장합니다.

## **전역 상태 관리 라이브러리 도입을 고려할 때 주의할 점이 있나요? 🤔**

**작은 규모의 프로젝트에서는 전역 상태 관리 라이브러리가 오버엔지니어링이 될 수 있다**는 점을 고려해야 합니다. 작은 규모임에도 도입한다면 오히려 불필요한 복잡성이 추가되어 개발 생산성이 저하될 수 있습니다. React의 내장 기능인 `useState`, `useContext`만으로도 충분할 수 있습니다.

프로젝트 규모가 크고 복잡한 상태 관리가 필요하거나, 여러 컴포넌트에서 공유해야 하는 상태가 많은 등 실제로 필요성이 느껴질 때 도입하는 것이 오버엔지니어링을 막을 수 있습니다.

</details>
<br/>

<details>
<summary>❓ useRef는 언제 사용하나요?</summary>
<br/>
`useRef()`는 React의 훅 중 하나로, **컴포넌트 내에서 변경 가능한 값을 저장하고 관리**할 수 있게 해줍니다. `useRef()`는 주로 두 가지 목적에 사용됩니다. **DOM 요소에 접근하거나, 값을 유지하면서도 렌더링을 트리거하지 않기 위해** 사용됩니다.

첫째, `useRef()`는 **DOM 요소에 접근할 때** 사용됩니다. 예를 들어, 특정 DOM 요소에 직접 접근하고 싶을 때 `useRef()`를 사용하여 해당 요소의 참조를 얻을 수 있습니다. 이는 `useEffect()`나 이벤트 핸들러 내에서 해당 DOM 요소에 직접 작업을 수행할 때 유용합니다. 예를 들어, 입력 필드에 포커스를 설정하고 싶을 때, `useRef()`를 사용해 input 요소에 접근할 수 있습니다.

```jsx
const inputRef = useRef(null);

useEffect(() => {
  inputRef.current.focus(); // 컴포넌트 마운트 시 input에 포커스를 맞춘다.
}, []);

return <input ref={inputRef} />;
```

둘째, **useRef는 값을 유지하면서도 렌더링을 트리거하지 않기 위해** 사용됩니다. 일반적으로 상태 값을 관리할 때 사용하는 `useState()`는 상태 변화가 리렌더링을 트리거하는 반면, `useRef()`는 값이 변경되어도 리렌더링을 트리거하지 않습니다. 예를 들어, 타이머 id를 추적할 때 `useRef()`를 사용할 수 있습니다.

```jsx
const timerRef = useRef(null);

const startTimer = () => {
  timerRef.current = setInterval(() => {
    console.log("타이머 실행");
  }, 1000);
};

const stopTimer = () => {
  clearInterval(timerRef.current); // 타이머를 정지한다.
};
```

위 예시에서 `useRef()`를 이용하여 타이머의 id를 추적하면서도 해당 상태 값이 업데이트될 때 컴포넌트를 리렌더링하지 않습니다.

</details>
<br/>

<details>
<summary>🛜 Server Action이란 무엇인가요?</summary>
<br/>
Server Action은 Next.js에서 제공하는 기능으로, **서버에서 실행되며 브라우저에서 호출할 수 있는 비동기 함수**입니다. 이 기능은 서버 로직을 직접 호출함으로써 클라이언트와 서버 간의 상호작용을 간소화할 수 있게 해줍니다. 예를 들면 백엔드 서버와 API 통신을 하는 대신 Next 서버에서 데이터베이스에 직접 접근하는 식으로 활용할 수 있습니다.

### **사용 방법**

Server Action은 `use server` 디렉티브를 사용하여 정의할 수 있습니다. 이 디렉티브는 함수가 서버에서만 실행되도록 지정합니다.

```tsx
"use server";

export async function createReviewAction(data: FormData) {
  const content = data.get("content");
  // 데이터베이스 저장 등의 작업
}
```

```tsx
// 컴포넌트에서 사용
<form action={createReviewAction}>
  <textarea name="content" required />
  <button type="submit">Submit</button>
</form>
```

이처럼 Server Action을 이용하면 폼이 제출될 때 해당 정보를 가지고 데이터베이스 저장과 같은 서버 작업을 수행할 수 있습니다.

## **Server Action의 장점은 무엇인가요? 🤔**

첫째, **클라이언트와 서버 간 상호작용을 간소화할 수 있습니다**. 기존에는 데이터베이스와 관련된 처리를 위해 백엔드 API와 통신하는 방식을 사용했습니다. 만약 Server Action을 이용한다면 백엔드 API와 통신하지 않고, Next 서버에서 직접 데이터베이스 작업을 수행할 수 있습니다. 이러한 점은 개발 생산성 향상에 도움이 될 수 있습니다. 또한 네트워크 통신을 줄여 성능 면에서도 이점이 있을 수 있습니다.

둘째, **Server Action 로직은 클라이언트에 전송되지 않습니다**. 이는 보안에 도움이 될 수 있습니다. 외부에 노출되면 안 되는 정보나 로직을 숨기는 데 활용할 수 있습니다. 더불어 클라이언트 단의 일부 로직을 Server Action으로 옮긴다면 번들의 크기가 줄어드는 데도 기여할 수 있습니다.

셋째, **JS가 로드되기 이전의 시점에도 서버와 상호작용할 수 있게 됩니다**. Server Action은 html `<form>`의 `action` 속성을 이용하여 폼 데이터를 서버에 전송합니다. 따라서 JS가 로드되지 않거나 비활성화되어도 서버와 통신이 가능하다는 장점이 있습니다.

</details>
<br/>

<details>
<summary>👊 클라이언트 사이드 라우팅이 동작하는 과정에 대해 설명해주세요.</summary>
<br/>
클라이언트 사이드 라우팅은 브라우저에서 페이지를 전환할 때 전체 페이지를 다시 불러오지 않고, 현재 로딩된 애플리케이션 내에서 필요한 컴포넌트만 교체하는 방식입니다.

클라이언트 사이드 라우팅의 과정에 대해 구체적으로 설명드리겠습니다.

기본적으로 사용자가 <Link to="/about">About</Link>와 같은 요소를 클릭하면, 브라우저는 바뀐 URL에 따라 전체 페이지를 다시 로드하려고 합니다. 하지만 React Router와 같은 라이브러리를 사용할 경우, 이 기본 동작은 막히게 됩니다.

이때 라우터는 window.history.pushState() 메서드를 호출하여 브라우저의 URL을 바꾸면서도, 실제로 서버에 요청은 보내지 않습니다. 즉, 브라우저 히스토리에 해당 URL을 추가만 할 뿐, 아무런 렌더링도 일으키지 않습니다. 대신 라우터는 별도로 현재 URL이 변경되었는지 감지하고, 그 경로에 매핑된 React 컴포넌트를 찾아서 렌더링합니다.

예를 들어, /about이라는 경로로 이동하면, Javascript 코드에 의해 라우터가 내부적으로 정의된 <Route path="/about" element={<AboutPage />}> 항목을 찾고, 이때 <AboutPage /> 컴포넌트가 렌더링됩니다. 이렇게 하면 전체 HTML을 다시 불러오지 않아도 브라우저가 마치 새로운 페이지로 이동한 것처럼 보이게 됩니다.

또한, 이 과정에서 필요한 데이터가 있다면, 새롭게 렌더링된 컴포넌트 내에서 useEffect() 등을 통해 API 요청을 보내거나 상태를 업데이트합니다. 이러한 동작이 JavaScript로 이뤄지기 때문에, 네트워크 요청은 서버 HTML이 아니라 데이터에 집중되고, 사용자에게는 빠른 페이지 전환을 제공할 수 있게 됩니다.

그리고 브라우저의 "뒤로 가기"나 "앞으로 가기" 버튼을 눌렀을 때는 popstate 이벤트가 발생합니다. 이때도 React Router는 해당 이벤트를 구독하고 있다가, 바뀐 URL을 다시 분석해서 그에 맞는 컴포넌트를 렌더링합니다. 따라서 사용자가 뒤로가기 버튼을 눌러도 전체 리프레시가 일어나지 않고, CSR 방식으로 화면 전환만 일어나게 됩니다.

</details>
<br/>

<details>
<summary>✈️ 리액트의 Batching Update </summary>
<br/>
리액트의 배칭 업데이트(Batching Update)는 여러 상태 업데이트를 하나의 리렌더링으로 그룹화하는 최적화 기법입니다.

리액트는 성능 향상을 위해 여러 setState 호출을 일괄 처리하여 불필요한 렌더링을 방지합니다.

예를 들어, 하나의 이벤트 핸들러 내에서 여러 번 상태를 업데이트하는 경우, 리액트는 이를 내부적으로 모아서 한 번의 업데이트로 처리합니다.

```
function handleClick() {
  setCount(c => c + 1); // 첫 번째 업데이트
  setFlag(f => !f);     // 두 번째 업데이트
  setName('리액트');     // 세 번째 업데이트
  // 이 세 가지 상태 변경은 배칭되어 단 한 번의 렌더링만 발생합니다
}
```

React 18 이전에는 이벤트 핸들러 내부와 같은 리액트가 제어하는 영역에서만 배칭이 적용되었습니다.

그러나 React 18부터는 '자동 배칭'이 도입되어 Promise, setTimeout, 네이티브 이벤트 핸들러 등 리액트 외부 영역에서도 배칭이 기본적으로 적용됩니다.

배칭을 통해 불필요한 리렌더링을 줄이고 계산 비용을 절감하여 애플리케이션의 성능을 향상시킬 수 있습니다.

React 18의 자동 배칭(Automatic Batching)이 이전 버전과 어떻게 다른가요? 🤔
React 18 이전에는 배칭이 React의 이벤트 핸들러 내부에서만 작동했습니다.

```
// React 17에서:
function handleClick() {
  setCount(c => c + 1); // 이벤트 핸들러 내부: 배칭 적용됨
  setFlag(f => !f);     // 배칭 적용됨 (한 번의 렌더링)
}

setTimeout(() => {
  setCount(c => c + 1); // React 외부 환경: 배칭 적용 안됨
  setFlag(f => !f);     // 배칭 적용 안됨 (두 번의 렌더링 발생)
}, 1000);
```

React 18에서는 자동 배칭이 도입되어 비동기 작업을 포함한 여러 상태 업데이트에 배칭이 적용됩니다.

Promise 내부
setTimeout/setInterval 내부
네이티브 이벤트 핸들러
기타 모든 이벤트 내부
이러한 변화로 개발자가 별도의 최적화 작업 없이도 더 효율적인 렌더링을 기대할 수 있게 되었습니다.

</details>
<br/>

<details>
<summary>🍃 React의 리렌더링 과정 </summary>
<br/>
React의 리렌더링 과정은 크게 Trigger, Render, Commit이라는 세 단계로 나눌 수 있습니다.

먼저 Trigger 단계는 컴포넌트의 state나 props가 변경되면서 시작됩니다. 사용자의 입력, 네트워크 응답 등의 이벤트에 의해 상태가 변경되면 React는 해당 컴포넌트를 다시 렌더링해야 한다고 판단합니다. 이때 React는 내부적으로 업데이트 큐에 해당 변경 사항을 등록합니다.

그다음 Render 단계에서는 변경된 상태를 바탕으로 새로운 Virtual DOM 트리를 생성합니다. 그후, 이전 Virtual DOM과 새 Virtual DOM을 비교하여 어떤 부분이 바뀌었는지를 분석합니다. 중요한 점은 이 시점에서는 실제 DOM에는 아무런 변경도 일어나지 않는다는 사실입니다.

마지막으로 Commit 단계에서는 이전 단계에서 분석된 변경 사항을 실제 DOM에 반영합니다. React는 변경에 필요한 최소한의 작업을 적용하여 DOM을 업데이트합니다. 변경이 발생하지 않은 요소는 수정하지 않고 그대로 둡니다. 이 단계에서 사용자에게 화면의 변화가 실제로 나타나게 됩니다.

## setState()가 호출될 때마다 매번 리렌더링이 발생하나요? 🤔

아니요. React의 auto batching 기능으로 인해, 여러 개의 상태 변경이 자동으로 하나의 batch로 묶여서 처리됩니다.

```
function App() {
  const [a, setA] = useState(0);
  const [b, setB] = useState(0);

  const handleClick = () => {
    setA(a + 1);
    setB(b + 1); // 이 둘은 하나로 합쳐져서 리렌더 1번
  };

  return <button onClick={handleClick}>Click</button>;
}
```

</details>
<br/>
