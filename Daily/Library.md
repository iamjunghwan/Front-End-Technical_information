<details>
<summary>🚗 tanstack-query에서 stale time과 gc time의 차이점에 대해서 설명해주세요 </summary>
<br/>
TanStack Query에서 `stale time`과 `gc time`은 데이터를 캐싱하고 관리하는 데 중요한 두 가지 설정입니다. 먼저 요약해서 말씀 드려보자면, `stale time`은 **데이터가 얼마나 오래 '신선한 상태'로 유지되는지**를 정하는 시간이고, `gc time`은 **데이터가 오래된 상태가 된 이후에도 캐시에서 얼마 동안 유지될지**를 정하는 시간입니다.

먼저, `stale time`은 데이터를 처음 가져온 후에 그 **데이터를 '신선한' 상태로 간주하는 시간**을 말합니다. 이 기간 동안에는 같은 데이터에 대한 추가적인 네트워크 요청이 일어나지 않고, 캐시에 저장된 데이터를 그대로 사용하게 됩니다. 예를 들어, `stale time`을 5분으로 설정하면, 데이터를 가져오고 나서 5분 동안은 이 데이터가 '신선하다'고 판단해서 네트워크 요청 없이 캐시된 데이터를 계속 사용합니다. `stale time`의 기본값은 0입니다.

반면에 gc time은 **데이터가 '오래된' 상태가 된 이후에도 캐시에 얼마 동안 남아 있을지를 정하는 시간**입니다. stale time이 지나면 데이터는 '오래된' 상태가 되지만, gc time이 설정되어 있으면 지정된 시간 동안 여전히 캐시에서 그 데이터를 유지하게 됩니다. 예를 들어, gc time을 10분으로 설정하면, 데이터가 stale 상태가 된 이후 10분 동안 캐시에 남아 있다가 자동으로 삭제됩니다. tanstack-query에서 설정한 기본 gc time은 5분입니다.

정리해서 말씀드려보자면, `stale time`은 **데이터를 처음 가져온 후 얼마 동안 네트워크 요청 없이 캐시된 데이터를 사용할지**를 정하는 시간이고, `gc time`은 그 **데이터가 오래된 상태가 된 후에도 캐시에 유지될** 시간을 정하는 겁니다. 이렇게 각각의 설정을 통해 데이터를 더 효율적으로 관리하고, 불필요한 네트워크 요청을 줄이면서도 최신 데이터를 가져올 수 있도록 합니다.

</details>
<br/>

<details>
<summary>🫧 리액트의 props와 state에 대해서 설명해주세요.</summary>
<br/>
`props`는 부모 컴포넌트가 자식 컴포넌트에 전달하는 데이터입니다. props는 읽기 전용으로, 자식 컴포넌트는 props를 수정할 수 없습니다.

```tsx
function ChildComponent(props) {
  props.name = "New Name"; // 오류 발생 가능
  return <div>{props.name}</div>;
}
```

이를 통해 컴포넌트 간의 데이터 흐름을 예측 가능하게 만들고, 컴포넌트의 재사용성을 높입니다.

`state`는 컴포넌트 내부에서 관리되는 데이터입니다. state는 동적으로 변경될 수 있으며, 컴포넌트의 렌더링에 영향을 미칩니다. state를 변경하면 컴포넌트는 다시 렌더링되며, UI가 업데이트됩니다. state는 주로 사용자 입력이나 네트워크 요청의 응답에 따라 변하는 데이터를 관리할 때 사용됩니다.

## **props가 자식 컴포넌트에서 변하지 않는 이유는 무엇인가요?**

props가 자식 컴포넌트에서 변하지 않는 이유는 리액트의 **단방향 데이터 흐름 원칙** 때문입니다. 리액트는 부모 컴포넌트가 자식 컴포넌트에 데이터를 전달할 때 단방향으로 전달하도록 설계되었습니다. 이렇게 하면 컴포넌트 간의 데이터 흐름을 예측 가능하고 일관성 있게 만들 수 있어 애플리케이션 상태 관리가 간단해집니다.

props는 **읽기 전용**이기 때문에, 부모 컴포넌트에서 전달된 값이 자식 컴포넌트 내에서 임의로 변경되지 않습니다. 이로 인해, 특정 상태가 어디서 어떻게 변했는지를 예측할 수 있어 버그 발생 가능성을 줄이고 디버깅을 쉽게 합니다.

만약 props가 변경될 수 있다면, 자식 컴포넌트는 독립적으로 동작하지 않게 되고, 재사용이 어려워질 수 있습니다. props가 불변으로 유지됨으로써 컴포넌트는 외부 입력에 의존할 뿐 내부적으로 변경하지 않아 재사용성이 높아지고, 코드의 캡슐화가 강화됩니다.

## **만약 자식 컴포넌트에서 부모 컴포넌트로부터 받은 props를 변경해야한다면 어떻게 해야할까요?**

만약 자식 컴포넌트가 부모로부터 받은 데이터를 수정해야 한다면, 상태를 부모 컴포넌트로 올려 부모 컴포넌트에서 props를 다시 전달하는 방식으로 구현해야 합니다. 이렇게 하면 데이터는 여전히 단방향으로 흐르고, 상태는 부모 컴포넌트가 관리해 일관성을 유지할 수 있습니다. 이러한 기법을 **상태 끌어올리기**라고 합니다.

</details>
<br/>

<details>
<summary>🚧 리액트의 Controlled Component와 Uncontrolled Component의 차이점에 대해서 설명해주세요. </summary>
<br/>
`Controlled Component`는 리액트 상태(state)를 통해 입력값을 제어하는 컴포넌트를 말합니다. 이 방식에서는 입력 요소의 값(value)을 리액트 상태와 동기화하고, 사용자가 입력을 변경할 때마다 onChange 이벤트 핸들러를 통해 상태를 업데이트합니다. useState를 활용한 input value를 제어하는 상황을 예시로 들 수 있습니다. value는 리액트 상태로 관리되며, onChange 이벤트가 발생할 때마다 상태가 업데이트됩니다. **Controlled Component의 주요 장점은 입력값이 리액트의 상태로 관리되므로, 입력값을 쉽게 검증하고, 변경할 수 있으며, 복잡한 폼 로직을 처리하는 데 유리**하다는 것입니다.

`Uncontrolled Component`는 리액트의 상태가 아닌, DOM 자체가 입력값을 제어하는 방식입니다. 즉, 입력 요소의 값은 DOM에서 직접 관리되며, 리액트는 이를 제어하지 않습니다. 이 방식에서는 `ref`를 사용하여 DOM 요소에 직접 접근해 값을 읽어오거나 조작할 수 있습니다.

input과 관련 된 ref는 useRef를 사용해 생성된 참조 객체로, 입력값을 직접 접근하고 조작할 수 있습니다. **Uncontrolled Component는 상대적으로 간단한 폼이나 초기값이 중요한 상황**에서 사용할 수 있습니다.

## **Controlled Component와 Uncontrolled Component를 통해 상태를 관리하는 것 중 어느 상황에 어떤 방법을 선택해야 하나요?**

ref를 사용하면 DOM을 통해 직접 접근하여 값을 읽어오기때문에, 단순한 입력 필드가 포함된 폼에서 ref를 사용하는 것이 더 간단하고 성능이 좋을 수 있습니다. 사용자가 제출 버튼을 클릭했을 때만 입력값을 가져오면 되는 경우를 예로 들 수 있습니다.

만약에 값을 입력할때마다 유효성 검증을 실시간을 해주어야하는 경우에는 Controlled Component를 사용하는 것이 좋습니다.

</details>
<br/>

<details>
<summary>🚑 리액트에서 성능 최적화를 위한 방법들을 설명해주세요. </summary>
<br/>
리액트에서 성능 최적화를 위해 여러 가지 방법을 사용할 수 있는데요. 대표적으로 메모이제이션을 말씀 드릴 수 있겠습니다.

리액트의 `memo`를 사용하여 컴포넌트를 메모이제이션할 수 있습니다. 이는 컴포넌트의 props가 변경되지 않았을 때, 리렌더링을 방지하여 성능을 최적화합니다. 이는 특히 렌더링 비용이 큰 컴포넌트에서 유용합니다.

또한 `useCallback`과 `useMemo`를 활용할 수도 있습니다. `useCallback` 은 함수를 메모이제이션하여 불필요한 함수 재생성을 방지하고, `useMemo`는 값의 재계산을 방지하여 성능을 최적화합니다. 이를 통해 자식 컴포넌트로 전달되는 함수나 값이 변경되지 않으면 리렌더링을 피할 수 있습니다.

마지막으로 `코드 스플리팅`을 활용해볼 수 있습니다. 코드 스플리팅은 큰 애플리케이션을 여러 개의 작은 청크로 나누어, 필요한 청크만 로드하게 하여 초기 로드 시간을 줄입니다. React.lazy와 Suspense를 사용하여 동적으로 컴포넌트를 로드할 수 있습니다.

## **그럼 코드 스플리팅은 어떤 경우에 사용해야할까요?**

첫번째로는 **초기 로딩 시간이 길어지는 경우**입니다. 애플리케이션이 커지면, 초기 로딩에 모든 코드를 로드하는 것이 비효율적일 수 있습니다. 코드 스플리팅을 사용해 초기 로드 시 필요한 핵심 코드만 로드하고, 이후 추가적인 기능은 필요할 때 로드하도록 하면 초기 로딩 속도를 크게 개선할 수 있습니다.

두번째로는 **라우트별 코드 분할이 필요한 경우**입니다. SPA에서는 각 페이지가 별도의 기능과 UI를 가지므로, 라우트별로 필요한 코드만 분리하여 로드할 수 있습니다. 이 방식은 리액트의 React.lazy와 Suspense를 사용하여 라우트별 컴포넌트를 동적으로 불러올 때 유용합니다.

</details>
<br/>

<details>
<summary>💥 리액트의 Strict Mode에 대해서 설명해주세요. </summary>
<br/>
리액트에서 `StrictMode`는 주로 개발 중에 발생할 수 있는 잠재적인 문제를 사전에 감지하고 예방하기 위해 사용됩니다. 몇 가지 주요 목적이 있습니다.

첫째로 오래된 라이프사이클 메서드와 비권장 API의 사용을 감지합니다. 예를 들어, `componentWillMount`, `componentWillReceiveProps`와 같은 메서드는 더 이상 사용이 권장되지 않는데, StrictMode는 이러한 메서드들이 코드에 포함된 경우 경고를 표시해줍니다. 이를 통해 개발자가 최신 React API를 사용하여 보다 안정적이고 효율적인 코드를 작성하도록 돕습니다.

둘째, **의도치 않은 부수 효과를 방지**합니다. 리액트는 컴포넌트의 렌더링이 예측 가능하고 순수하게 이루어지기를 기대합니다. StrictMode는 이를 검증하기 위해 useEffect, useState 등 일부 훅이나 메서드를 두 번씩 실행합니다. 이렇게 두 번 실행되는 이유는, 동일한 결과가 나오는지 확인함으로써 컴포넌트가 사이드 이펙트를 일으키지 않고 순수하게 동작하는지를 검사하기 위함입니다.

이러한 검증이 중요한 이유는 예기치 않은 동작이나 버그를 사전에 방지하기 위해서입니다. 개발 환경에서 두 번씩 실행해봤을 때 문제가 발생하지 않으면, 프로덕션에서도 안전하게 실행된다는 신호라고 볼 수 있습니다. 이 과정에서 부수 효과가 감지되면 개발자는 코드를 수정해야 할 필요가 있습니다.

다만, 이러한 두 번 실행되는 현상은 개발 모드에서만 발생하고, 실제 프로덕션 빌드에서는 정상적으로 한 번만 실행되기 때문에 성능에 영향을 미치지 않습니다.

이렇게 StrictMode는 개발자가 더욱 안전하고 효율적인 코드를 작성할 수 있도록 도와주는 도구라고 말씀드릴 수 있습니다.

</details>
<br/>

<details>
<summary>🐣 리액트의 render phase와 commit phase에 대해서 설명해주세요. </summary>
<br/>
리액트의 렌더링 과정은 크게 두 가지 단계로 나눌 수 있습니다. `render phase`와 `commit phase`입니다.

먼저 `render phase`는 리액트가 변화된 상태나 props에 따라 어떤 **UI가 변경되어야 할지를 결정하는 단계**입니다. 이 과정에서는 실제로 DOM을 업데이트하지 않고, 변경사항을 가상 DOM에서 계산하여 비교합니다. 이 단계는 순수하게 계산과정이기 때문에 성능에 영향을 주지 않도록 중단되거나 다시 실행될 수 있으며, React 18에서 도입된 Concurrent Mode를 통해 비동기적으로 처리될 수도 있습니다.

다음으로 commit phase는 실제로 변화된 **UI를 DOM에 반영하는 단계**입니다. 이때 리액트는 가상 DOM에서 계산된 결과를 실제 DOM에 적용하고, 변화된 UI를 브라우저에 렌더링합니다. 이 과정에서는 useEffect와 같은 사이드 이펙트가 발생하는 훅들이 실행됩니다.

요약해서 말씀드려보자면 render phase는 변화된 UI를 결정하는 과정이고, commit phase는 그 결정된 결과를 실제로 반영하는 단계입니다.

## **그럼 render phase와 commit phase는 어떻게 동기화되나요?**

두가지의 단계로 말씀드릴 수 있습니다. **단계적 진행**과 **병목 관리**입니다. 첫번째로 render phase가 완료되면 리액트는 즉시 commit phase를 실행하지 않고, 다른 높은 우선순위 작업이 있다면 먼저 처리한 후 나중에 commit phase를 실행할 수 있습니다. 이를 통해 React는 동기화가 필요한 작업을 효율적으로 관리하여 사용자 경험을 개선합니다.

두번째로 **병목 관리**입니다. render phase에서 모든 변경 사항이 Fiber Tree에 준비된 상태에서 commit phase로 넘어가므로, render와 commit 단계의 일관성이 유지됩니다. 이렇게 두 단계는 순차적으로 작동하여, UI가 정확하게 동기화되고 불필요한 재렌더링을 방지합니다.

</details>
<br/>
